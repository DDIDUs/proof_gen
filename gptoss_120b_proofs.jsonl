{"input": "lemma corres_throwError_str [corresK_concrete_rER]:\n  \"corres_underlyingK sr nf nf' (r (Inl a) (Inl b)) r \\<top> \\<top> (throwError a) (throw b)\"\n  \"corres_underlyingK sr nf nf' (r (Inl a) (Inl b)) r \\<top> \\<top> (throwError a) (throwError b)\"", "gt": "by (simp add: corres_underlyingK_def)+", "baseline_output": "```isabelle\nlemma corres_throwError_str [corresK_concrete_rER]:\n  \"corres_underlyingK sr nf nf' (r (Inl a) (Inl b)) r \\<top> \\<top> (throwError a) (throw b)\"\n  \"corres_underlyingK sr nf nf' (r (Inl a) (Inl b)) r \\<top> \\<top> (throwError a) (throwError b)\"\n  by (simp_all add: corres_underlyingK_def)\n```", "fs_baseline_output": "```isabelle\nlemma corres_throwError_str [corresK_concrete_rER]:\n  \"corres_underlyingK sr nf nf' (r (Inl a) (Inl b)) r \\<top> \\<top> (throwError a) (throw b)\"\n  \"corres_underlyingK sr nf nf' (r (Inl a) (Inl b)) r \\<top> \\<top> (throwError a) (throwError b)\"\n  by (simp add: corres_underlyingK_def)\n```"}
{"input": "lemma corresK_use_guard:\n  \"(F \\<Longrightarrow> corres_underlyingK sr nf nf' F r Q Q' f g) \\<Longrightarrow> corres_underlyingK sr nf nf' F r Q Q' f g\"", "gt": "by (simp add: corres_underlyingK_def)", "baseline_output": "```isabelle\nlemma corresK_use_guard:\n  \"(F \\<Longrightarrow> corres_underlyingK sr nf nf' F r Q Q' f g) \\<Longrightarrow> corres_underlyingK sr nf nf' F r Q Q' f g\"\n  by (auto)\n```", "fs_baseline_output": "```isabelle\nlemma corresK_use_guard:\n  \"(F \\<Longrightarrow> corres_underlyingK sr nf nf' F r Q Q' f g) \\<Longrightarrow> corres_underlyingK sr nf nf' F r Q Q' f g\"\n  by (simp add: corres_underlyingK_def)\n```"}
{"input": "lemma corresK_mapM:\n  assumes S: \"set (zip xs ys) \\<subseteq> S\"\n  assumes z: \"\\<And>x y. corres_protect ((x, y) \\<in> S) \\<Longrightarrow> corres_underlyingK R nf nf' (F x y) r' P P' (f x) (f' y)\"\n  assumes w: \"\\<And>x y. (x, y) \\<in> S \\<Longrightarrow> \\<lbrace>P\\<rbrace> f x \\<lbrace>\\<lambda>rv. P\\<rbrace>\"\n             \"\\<And>x y. (x, y) \\<in> S \\<Longrightarrow> \\<lbrace>P'\\<rbrace> f' y \\<lbrace>\\<lambda>rv. P'\\<rbrace>\"\n  shows      \"corres_underlyingK R nf nf'\n                  ((length xs = length ys) \\<and>\n                   (r [] []) \\<and> (\\<forall>x xs y ys. r xs ys \\<longrightarrow> r' x y \\<longrightarrow> r (x # xs) (y # ys)) \\<and>\n                  (\\<forall>(x,y)\\<in>S. F x y)) r P P' (mapM f xs) (mapM f' ys)\"\n  unfolding corres_underlyingK_def\n  apply (rule impI, rule corres_mapM[of r r' S])", "gt": "by (auto simp: corres_protect_def)", "baseline_output": "```isabelle\nlemma corresK_mapM:\n  assumes S: \"set (zip xs ys) \\<subseteq> S\"\n  assumes z: \"\\<And>x y. (x, y) \\<in> S ⟹ corres_protect ((x, y) ∈ S) ⟹\n               corres_underlyingK R nf nf' (F x y) r' P P' (f x) (f' y)\"\n  assumes w: \"\\<And>x y. (x, y) \\<in> S ⟹ \\<lbrace>P\\<rbrace> f x \\<lbrace>\\<lambda>rv. P\\<rbrace>\"\n               \"\\<And>x y. (x, y) \\<in> S ⟹ \\<lbrace>P'\\<rbrace> f' y \\<lbrace>\\<lambda>rv. P'\\<rbrace>\"\n  shows \"corres_underlyingK R nf nf'\n                  ((length xs = length ys) \\<and>\n                   (r [] []) \\<and> (\\<forall>x xs y ys. r xs ys ⟶ r' x y ⟶ r (x # xs) (y # ys)) \\<and>\n                  (\\<forall>(x,y)∈S. F x y)) r P P' (mapM f xs) (mapM f' ys)\"\n  unfolding corres_underlyingK_def\n  apply (rule impI)\n  apply (rule corres_mapM[of r r' S])\n    apply (auto simp: S)\n   apply (intro z)\n   apply simp\n  done\n```", "fs_baseline_output": "```isabelle\nlemma corresK_mapM:\n  assumes S: \"set (zip xs ys) \\<subseteq> S\"\n  assumes z: \"\\<And>x y. corres_protect ((x, y) \\<in> S) \\<Longrightarrow>\n               corres_underlyingK R nf nf' (F x y) r' P P' (f x) (f' y)\"\n  assumes w: \"\\<And>x y. (x, y) \\<in> S \\<Longrightarrow> \\<lbrace>P\\<rbrace> f x \\<lbrace>\\<lambda>rv. P\\<rbrace>\"\n              \"\\<And>x y. (x, y) \\<in> S \\<Longrightarrow> \\<lbrace>P'\\<rbrace> f' y \\<lbrace>\\<lambda>rv. P'\\<rbrace>\"\n  shows \"corres_underlyingK R nf nf'\n                  ((length xs = length ys) \\<and>\n                   (r [] []) \\<and>\n                   (\\<forall>x xs y ys. r xs ys \\<longrightarrow> r' x y \\<longrightarrow> r (x # xs) (y # ys)) \\<and>\n                   (\\<forall>(x,y)\\<in>S. F x y)) r P P' (mapM f xs) (mapM f' ys)\"\n  unfolding corres_underlyingK_def\n  apply (rule impI)\n  apply (rule corres_mapM[of r r' S])\n   apply (simp add: S)\n  apply (intro allI impI)\n   apply (erule (1) z)\n  apply (intro allI impI)\n   apply (erule (1) w(1))\n  apply (erule (1) w(2))\n  done\n```"}
{"input": "lemma F_all2_pointwise[simp]:\n  \"F_all2 (\\<lambda>x y _ _. F x y) xs ys = list_all2 F xs ys\"\n  apply (rule iffI)\n  apply (clarsimp simp: F_all2_def)\n  subgoal for F'\n  apply (rule list_all2_induct_suffixeq[where Q=F']; simp)\n  apply (drule_tac x=x in spec)\n  apply (drule_tac x=y in spec)\n  apply fastforce\n  done\n  apply (clarsimp simp:F_all2_def)\n  apply (rule_tac x=F in exI)\n  apply clarsimp\n  done\n\nlemma F_all2_list:\n   \"F xs ys \\<Longrightarrow> \\<exists>F'. (\\<forall>xs ys. (F xs ys = list_all2 F' xs ys)) \\<Longrightarrow> F_all2 (\\<lambda>_ _ xs ys. F xs ys) xs ys\"\n  apply (clarsimp simp: F_all2_def)\n  apply (rule_tac x=F' in exI)", "gt": "by auto", "baseline_output": "```isabelle\nlemma F_all2_list:\n  assumes \"F xs ys\"\n    and \"\\<exists>F'. (\\<forall>xs ys. F xs ys = list_all2 F' xs ys)\"\n  shows \"F_all2 (\\<lambda>_ _ xs ys. F xs ys) xs ys\"\nusing assms\nunfolding F_all2_def\nby (auto)\n```", "fs_baseline_output": "```isabelle\nlemma F_all2_pointwise[simp]:\n  \"F_all2 (\\<lambda>x y _ _. F x y) xs ys = list_all2 F xs ys\"\n  apply (rule iffI)\n   apply (clarsimp simp: F_all2_def)\n   subgoal for F'\n    apply (rule list_all2_induct_suffixeq[where Q=F'])\n    apply (simp)\n    apply (drule_tac x=x in spec)\n    apply (drule_tac x=y in spec)\n    apply fastforce\n    done\n  apply (clarsimp simp: F_all2_def)\n  apply (rule_tac x=F in exI)\n  apply clarsimp\n  done\n\nlemma F_all2_list:\n  assumes \"F xs ys\"\n    and \"\\<exists>F'. (\\<forall>xs ys. F xs ys = list_all2 F' xs ys)\"\n  shows \"F_all2 (\\<lambda>_ _ xs ys. F xs ys) xs ys\"\nproof -\n  obtain F' where \"\\<forall>xs ys. F xs ys = list_all2 F' xs ys\"\n    using assms(2) by blast\n  then show ?thesis\n    unfolding F_all2_def\n    by (rule exI[where x=F'], auto)\nqed\n```"}
{"input": "lemma list_all2_conjD:\n  \"list_all2 (\\<lambda>x y. Q x y \\<and> P x y) xs ys \\<Longrightarrow> list_all2 Q xs ys \\<and> list_all2 P xs ys\"", "gt": "by (induct rule: list_all2_induct; simp)", "baseline_output": "```isabelle\nlemma list_all2_conjD:\n  \"list_all2 (\\<lambda>x y. Q x y \\<and> P x y) xs ys ⟹ list_all2 Q xs ys ∧ list_all2 P xs ys\"\n  by (induction xs ys rule: list_all2.induct) auto\n```", "fs_baseline_output": "```isabelle\nlemma list_all2_conjD:\n  \"list_all2 (\\<lambda>x y. Q x y \\<and> P x y) xs ys ⟹ list_all2 Q xs ys \\<and> list_all2 P xs ys\"\n  by (induction xs ys rule: list_all2.induct) (auto simp: list_all2_cons list_all2_nil)\n```"}
{"input": "lemma\n  list_all2_to_list_all:\n  \"list_all2 P xs xs = list_all (\\<lambda>x. P x x) xs\"", "gt": "by (induct xs;simp)", "baseline_output": "```isabelle\nlemma list_all2_to_list_all:\n  \"list_all2 P xs xs = list_all (\\<lambda>x. P x x) xs\"\n  by (induction xs) auto\n```", "fs_baseline_output": "```isabelle\nlemma list_all2_to_list_all:\n  \"list_all2 P xs xs = list_all (\\<lambda>x. P x x) xs\"\n  by (induction xs) (auto simp: list_all2_def)\n```"}
{"input": "lemma list_all_mem_subset:\n  \"list_all (\\<lambda>y. y \\<in> set xs) ys = (set ys \\<subseteq> set xs)\"", "gt": "by (induct ys; simp)", "baseline_output": "```isabelle\nlemma list_all_mem_subset:\n  \"list_all (\\<lambda>y. y \\<in> set xs) ys = (set ys \\<subseteq> set xs)\"\n  by (simp add: list_all_iff subset_eq)\n```", "fs_baseline_output": "```isabelle\nlemma list_all_mem_subset:\n  \"list_all (\\<lambda>y. y \\<in> set xs) ys = (set ys \\<subseteq> set xs)\"\n  by (simp add: list_all_iff subset_eq)\n```"}
{"input": "lemma F_all2_eq:\n  \"(\\<And>x xs'. x \\<in> set xs \\<Longrightarrow> set xs' \\<subseteq> set xs \\<Longrightarrow> F x x xs' xs') \\Longrightarrow> F_all2 F xs xs\"\n apply (simp add: F_all2_def)\n apply (rule_tac x=\"\\<lambda>x y. x \\<in> set xs \\<and> x = y\" in exI)\n apply (intro conjI impI allI)\n apply (drule list_all2_conjD)\n apply (simp add: list.rel_eq)\n apply (simp add: list_all2_to_list_all list_all_mem_subset)\n apply (rule list.rel_refl_strong;simp)\n done\n\nlemma F_all2_conjI:\n  \"F_all2 F xs ys \\<Longrightarrow> F_all2 F' xs ys \\<Longrightarrow>\n    F_all2 (\\<lambda>x y xs ys. F x y xs ys \\<and> F' x y xs ys) xs ys\"\n  apply (clarsimp simp: F_all2_def)\n  apply (rule_tac x=\"\\<lambda>x y. F'a x y \\<and> F'aa x y\" in exI)", "gt": "by (auto dest: list_all2_conjD intro: list_all2_conj)", "baseline_output": "```isabelle\nlemma F_all2_conjI:\n  \"F_all2 F xs ys ⟹ F_all2 F' xs ys ⟹\n    F_all2 (\\<lambda>x y xs ys. F x y xs ys \\<and> F' x y xs ys) xs ys\"\n  unfolding F_all2_def\n  apply (erule exE)+\n  apply (rule exI[where x=\"\\<lambda>x y. R x y \\<and> R' x y\"])\n  apply (intro conjI)\n   apply (clarsimp)\n  apply (rule list_all2_conjI)\n    apply assumption+\n  done\n```", "fs_baseline_output": "```isabelle\nlemma F_all2_eq:\n  \"(\\<And>x xs'. x \\<in> set xs \\<Longrightarrow> set xs' \\<subseteq> set xs \\<Longrightarrow> F x x xs' xs') \\<Longrightarrow> F_all2 F xs xs\"\n  apply (simp add: F_all2_def)\n  apply (rule_tac x=\"\\<lambda>x y. x \\<in> set xs \\<and> x = y\" in exI)\n  apply (intro conjI impI allI)\n   apply (drule list_all2_conjD)\n   apply (simp add: list.rel_eq)\n   apply (simp add: list_all2_to_list_all list_all_mem_subset)\n   apply (rule list.rel_refl_strong; simp)\n  done\n\nlemma F_all2_conjI:\n  \"F_all2 F xs ys \\<Longrightarrow> F_all2 F' xs ys \\<Longrightarrow>\n    F_all2 (\\<lambda>x y xs ys. F x y xs ys \\<and> F' x y xs ys) xs ys\"\n  apply (clarsimp simp: F_all2_def)\n  apply (erule exE)+\n  apply (rule_tac x=\"\\<lambda>x y. R x y \\<and> R' x y\" in exI)\n  apply (intro conjI)\n   apply (rule list_all2_conjI)\n    apply (assumption)+\n  apply (intro allI impI)\n   apply (erule conjE)\n   apply (auto)\n  done\n```"}
{"input": "lemma corresK_mapM_list_all2:\n  assumes x: \"\\<And>x y xs ys. corres_underlyingK sr nf nf' (F x y xs ys) r' (I (x#xs)) (I' (y#ys)) (f x) (f' y)\"\n  assumes \"\\<And>x y xs. \\<lbrakk> S x y; suffix (x#xs) as \\rbrakk> \\Longrightarrow> \\<lbrace> I  (x#xs) \\<rbrace> f  x \\<lbrace> \\<lambda>rv. I  xs \\<rbrace>\"\n  assumes \"\\<And>x y ys. \\<lbrakk> S x y; suffix (y#ys) cs \\rbrakk> \\Longrightarrow> \\<lbrace> I' (y#ys) \\<rbrace> f' y \\<lbrace> \\<lambda>rv. I' ys \\<rbrace>\"\n  shows \"corres_underlyingK sr nf nf'\n          (r [] [] \\<and> (\\<forall> x y xs ys. r' x y \\longrightarrow> r xs ys \\longrightarrow> r (x # xs) (y # ys)) \\and>\n            list_all2 S as cs \\and> F_all2 F as cs)\n                            r (I as) (I' cs) (mapM f as) (mapM f' cs)\"\n  unfolding corres_underlyingK_def\n  apply (clarsimp simp: F_all2_def)\n  subgoal for F'\n  apply (rule corres_mapM_list_all2[of r r' \"\\<lambda>x y. S x y \\<and> F' x y\"]; (rule assms | assumption | clarsimp)?)\n  apply (rule x[THEN corresK_unlift])\n  apply (drule list_all2_conjD)\n  apply (clarsimp simp: assms | assumption)+\n  apply (rule list_all2_conj; simp)\n  done\n  done\n\nlemma corresK_discard_rv:\n  assumes A[corresK]: \"corres_underlyingK sr nf nf' F r' P P' a c\"\n  shows \"corres_underlyingK sr nf nf' F dc P P' (do x \\<leftarrow> a; return () od) (do x \\<leftarrow> c; return () od)\"", "gt": "by corresKsimp", "baseline_output": "```isabelle\nlemma corresK_discard_rv:\n  assumes A[corresK]: \"corres_underlyingK sr nf nf' F r' P P' a c\"\n  shows \"corres_underlyingK sr nf nf' F dc P P' (do x \\<leftarrow> a; return () od) (do x \\<leftarrow> c; return () od)\"\nproof -\n  have \"corres_underlyingK sr nf nf' F r' P P' a c\" using A .\n  then show ?thesis\n    unfolding dc_def\n    by (rule corresK_unlift) (auto simp: bind_def)\nqed\n```", "fs_baseline_output": "```isabelle\nlemma corresK_discard_rv:\n  assumes A[corresK]: \"corres_underlyingK sr nf nf' F r' P P' a c\"\n  shows \"corres_underlyingK sr nf nf' F dc P P' (do x \\<leftarrow> a; return () od) (do x \\<leftarrow> c; return () od)\"\n  unfolding corres_underlyingK_def dc_def\n  using A by (simp add: bind_return_unit)\n```"}
{"input": "lemma corresK_mapM_mapM_x:\n  assumes \"corres_underlyingK sr nf nf' F r' P P' (mapM f as) (mapM f' cs)\"\n  shows \"corres_underlyingK sr nf nf' F dc P P' (mapM_x f as) (mapM_x f' cs)\"", "gt": "by (rule corresK_discard_rv, rule assms)", "baseline_output": "```isabelle\nlemma corresK_mapM_mapM_x:\n  assumes \"corres_underlyingK sr nf nf' F r' P P' (mapM f as) (mapM f' cs)\"\n  shows \"corres_underlyingK sr nf nf' F dc P P' (mapM_x f as) (mapM_x f' cs)\"\n  using assms\n  unfolding mapM_x_def\n  by (simp add: corres_underlyingK_bind)\n```", "fs_baseline_output": "```isabelle\nlemma corresK_mapM_mapM_x:\n  assumes \"corres_underlyingK sr nf nf' F r' P P' (mapM f as) (mapM f' cs)\"\n  shows \"corres_underlyingK sr nf nf' F dc P P' (mapM_x f as) (mapM_x f' cs)\"\n  unfolding mapM_x_def\n  by (rule corres_underlyingK_bind[OF assms]) (simp)\n```"}
{"input": "lemma corresK_subst_both: \"g' = f' \\<Longrightarrow> g = f \\<Longrightarrow>\n  corres_underlyingK sr nf nf' F r P P' f f' \\<Longrightarrow>", "gt": "by simp", "baseline_output": "```isabelle\nlemma corresK_subst_both:\n  \"g' = f' \\<Longrightarrow> g = f \\<Longrightarrow>\n   corres_underlyingK sr nf nf' F r P P' f f' \\<Longrightarrow>\n   corres_underlyingK sr nf nf' F r P P' g g'\"\n  by (simp add: assms)\n```", "fs_baseline_output": "```isabelle\nlemma corresK_subst_both:\n  \"g' = f' ⟹ g = f ⟹\n   corres_underlyingK sr nf nf' F r P P' f f' ⟹\n   corres_underlyingK sr nf nf' F r P P' g g'\"\n  by (simp)\n```"}
