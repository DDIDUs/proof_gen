{"input": "lemma corres_throwError_str [corresK_concrete_rER]:\n  \"corres_underlyingK sr nf nf' (r (Inl a) (Inl b)) r \\<top> \\<top> (throwError a) (throw b)\"\n  \"corres_underlyingK sr nf nf' (r (Inl a) (Inl b)) r \\<top> \\<top> (throwError a) (throwError b)\"", "gt": "by (simp add: corres_underlyingK_def)+", "baseline_output": "```isabelle\nlemma corres_throwError_str [corresK_concrete_rER]:\n  \"corres_underlyingK sr nf nf' (r (Inl a) (Inl b)) r \\<top> \\<top> (throwError a) (throw b)\"\n  \"corres_underlyingK sr nf nf' (r (Inl a) (Inl b)) r \\<top> \\<top> (throwError a) (throwError b)\"\n  by (auto simp: corres_underlyingK_def throwError_def return_def bind_def split: sum.splits)\n```", "cot_sketch": "- The lemma states two corollaries about the correspondence between `throwError` and `throw`/`throwError` operations under certain relations and conditions.\n- Proof strategy: Use the definitions and properties of `corres_underlyingK`, `throwError`, and `throw`.\n- First corollary: \n  - Expand `corres_underlyingK` to understand its structure.\n  - Simplify the conditions involving `r (Inl a) (Inl b)` and the top predicates.\n  - Show that `throwError a` and `throw b` behave according to the relation `r` when both are left injections (`Inl`).\n  - Use the definition of `throwError` and `throw` to demonstrate the correspondence.\n- Second corollary:\n  - Similarly, expand `corres_underlyingK` and simplify the conditions.\n  - Demonstrate that `throwError a` and `throwError b` maintain the relation `r` when both are left injections.\n  - Leverage the definition of `throwError` to prove the correspondence.\n- Tactics: (unfold definitions of `corres_underlyingK`, `throwError`, `throw`; simp; auto).", "cot_output": "```isabelle\nlemma corres_throwError_str [corresK_concrete_rER]:\n  \"corres_underlyingK sr nf nf' (r (Inl a) (Inl b)) r \\<top> \\<top> (throwError a) (throw b)\"\n  \"corres_underlyingK sr nf nf' (r (Inl a) (Inl b)) r \\<top> \\<top> (throwError a) (throwError b)\"\n  unfolding corres_underlyingK_def throwError_def throw_def\n  by (auto simp: return_def)\n```", "fs_baseline_output": "```isabelle\nlemma corres_throwError_str [corresK_concrete_rER]:\n  \"corres_underlyingK sr nf nf' (r (Inl a) (Inl b)) r \\<top> \\<top> (throwError a) (throw b)\"\n  \"corres_underlyingK sr nf nf' (r (Inl a) (Inl b)) r \\<top> \\<top> (throwError a) (throwError b)\"\n  unfolding throwError_def throw_def\n  by (auto simp: corres_underlyingK_def return_def bind_def)\n```", "fs_cot_sketch": "- The lemma states two corollaries about the correspondence between `throwError` and `throw`/`throwError` operations under a specific relation `r`.\n- Proof strategy: Use the definitions and properties of `corres_underlyingK`, `throwError`, and `throw` to establish the required correspondences.\n- First corollary: Show that `corres_underlyingK sr nf nf' (r (Inl a) (Inl b)) r \\<top> \\<top> (throwError a) (throw b)` holds.\n  - Expand the definition of `corres_underlyingK` for both `throwError a` and `throw b`.\n  - Demonstrate that the execution of `throwError a` results in a failure with value `a`, and `throw b` results in a failure with value `b`.\n  - Use the relation `r (Inl a) (Inl b)` to link these failures.\n- Second corollary: Show that `corres_underlyingK sr nf nf' (r (Inl a) (Inl b)) r \\<top> \\<top> (throwError a) (throwError b)` holds.\n  - Similarly, expand the definition of `corres_underlyingK` for both `throwError a` and `throwError b`.\n  - Demonstrate that both operations result in a failure with value `a` and `b` respectively.\n  - Use the relation `r (Inl a) (Inl b)` to link these failures.\n- Tactics: Use `unfold` to expand definitions of `corres_underlyingK`, `throwError`, and `throw`. Apply `auto` or `simp` to simplify the resulting goals. Use `rule` to apply relevant lemmas or definitions directly.", "fs_cot_output": "```isabelle\nlemma corres_throwError_str [corresK_concrete_rER]:\n  \"corres_underlyingK sr nf nf' (r (Inl a) (Inl b)) r \\<top> \\<top> (throwError a) (throw b)\"\n  \"corres_underlyingK sr nf nf' (r (Inl a) (Inl b)) r \\<top> \\<top> (throwError a) (throwError b)\"\n  unfolding corres_underlyingK_def throwError_def throw_def\n  by (auto simp: return_def bind_def fail_def split: sum.splits)\n```"}
{"input": "lemma corresK_use_guard:\n  \"(F \\<Longrightarrow> corres_underlyingK sr nf nf' F r Q Q' f g) \\<Longrightarrow> corres_underlyingK sr nf nf' F r Q Q' f g\"", "gt": "by (simp add: corres_underlyingK_def)", "baseline_output": "```isabelle\nlemma corresK_use_guard:\n  \"(F \\<Longrightarrow> corres_underlyingK sr nf nf' F r Q Q' f g) \\<Longrightarrow> corres_underlyingK sr nf nf' F r Q Q' f g\"\n  by simp\n```", "cot_sketch": "- The lemma states that if a condition \\( F \\) implies a correspondence between two functions \\( f \\) and \\( g \\), then the same correspondence holds under the assumption that \\( F \\) is true.\n- Proof strategy: Direct proof since the implication directly leads to the conclusion.\n- Key observation: The premise \\( F \\Rightarrow \\text{corres\\_underlyingK} \\, sr \\, nf \\, nf' \\, F \\, r \\, Q \\, Q' \\, f \\, g \\) means that whenever \\( F \\) is true, the correspondence holds.\n- Since the goal is to prove the same correspondence under the assumption that \\( F \\) is true, we can directly use the premise.\n- Tactics: (unfold definitions; assumption).", "cot_output": "```isabelle\nlemma corresK_use_guard:\n  \"(F \\<Longrightarrow> corres_underlyingK sr nf nf' F r Q Q' f g) \\<Longrightarrow> corres_underlyingK sr nf nf' F r Q Q' f g\"\n  by (assumption)\n```", "fs_baseline_output": "```isabelle\nlemma corresK_use_guard:\n  \"(F \\<Longrightarrow> corres_underlyingK sr nf nf' F r Q Q' f g) \\<Longrightarrow> corres_underlyingK sr nf nf' F r Q Q' f g\"\n  by simp\n```", "fs_cot_sketch": "- The lemma states that if a condition \\( F \\) holds, then the correspondence between two functions \\( f \\) and \\( g \\) under certain conditions remains unchanged.\n- Proof strategy: Direct proof since the conclusion is essentially a restatement of the premise under the assumption \\( F \\).\n- Since the premise directly implies the conclusion, no additional steps or cases are needed.\n- Key tactic: Simplification to show that the premise directly entails the conclusion.", "fs_cot_output": "```isabelle\nlemma corresK_use_guard:\n  \"(F \\<Longrightarrow> corres_underlyingK sr nf nf' F r Q Q' f g) \\<Longrightarrow> corres_underlyingK sr nf nf' F r Q Q' f g\"\n  by simp\n```"}
{"input": "lemma corresK_mapM:\n  assumes S: \"set (zip xs ys) \\<subseteq> S\"\n  assumes z: \"\\<And>x y. corres_protect ((x, y) \\<in> S) \\<Longrightarrow> corres_underlyingK R nf nf' (F x y) r' P P' (f x) (f' y)\"\n  assumes w: \"\\<And>x y. (x, y) \\<in> S \\<Longrightarrow> \\<lbrace>P\\<rbrace> f x \\<lbrace>\\<lambda>rv. P\\<rbrace>\"\n             \"\\<And>x y. (x, y) \\<in> S \\<Longrightarrow> \\<lbrace>P'\\<rbrace> f' y \\<lbrace>\\<lambda>rv. P'\\<rbrace>\"\n  shows      \"corres_underlyingK R nf nf'\n                  ((length xs = length ys) \\<and>\n                   (r [] []) \\<and> (\\<forall>x xs y ys. r xs ys \\<longrightarrow> r' x y \\<longrightarrow> r (x # xs) (y # ys)) \\<and>\n                  (\\<forall>(x,y)\\<in>S. F x y)) r P P' (mapM f xs) (mapM f' ys)\"\n  unfolding corres_underlyingK_def\n  apply (rule impI, rule corres_mapM[of r r' S])", "gt": "by (auto simp: corres_protect_def)", "baseline_output": "```isabelle\nlemma corresK_mapM:\n  assumes S: \"set (zip xs ys) \\<subseteq> S\"\n  assumes z: \"\\<And>x y. corres_protect ((x, y) \\<in> S) \\<Longrightarrow> corres_underlyingK R nf nf' (F x y) r' P P' (f x) (f' y)\"\n  assumes w: \"\\<And>x y. (x, y) \\<in> S \\<Longrightarrow> \\<lbrace>P\\<rbrace> f x \\<lbrace>\\<lambda>rv. P\\<rbrace>\"\n             \"\\<And>x y. (x, y) \\<in> S \\<Longrightarrow> \\<lbrace>P'\\<rbrace> f' y \\<lbrace>\\<lambda>rv. P'\\<rbrace>\"\n  shows      \"corres_underlyingK R nf nf'\n                  ((length xs = length ys) \\<and>\n                   (r [] []) \\<and> (\\<forall>x xs y ys. r xs ys \\<longrightarrow> r' x y \\<longrightarrow> r (x # xs) (y # ys)) \\<and>\n                  (\\<forall>(x,y)\\<in>S. F x y)) r P P' (mapM f xs) (mapM f' ys)\"\n  unfolding corres_underlyingK_def\n  apply (rule impI, rule corres_mapM[of r r' S])\n  apply (clarsimp simp add: zip_mapM)\n  apply (rule_tac x=\"\\<lambda>xs ys. r xs ys\" in exI)\n  apply (clarsimp simp add: mapM_cong)\n  apply (rule_tac x=\"\\<lambda>x y. r' x y\" in exI)\n  apply (clarsimp simp add: mapM_cong)\n  apply (rule_tac x=\"\\<lambda>x y. F x y\" in exI)\n  apply (clarsimp simp add: mapM_cong)\n  apply (rule_tac x=\"\\<lambda>x y. corres_protect ((x, y) \\<in> S)\" in exI)\n  apply (clarsimp simp add: mapM_cong)\n  apply (rule_tac x=\"\\<lambda>x y. w x y\" in exI)\n  apply (clarsimp simp add: mapM_cong)\n  apply (rule_tac x=\"\\<lambda>x y. w x y\" in exI)\n  apply (clarsimp simp add: mapM_cong)\n  apply (rule_tac x=\"\\<lambda>x y. z x y\" in exI)\n  apply (clarsimp simp add: mapM_cong)\n  done\n```", "cot_sketch": "- The lemma `corresK_mapM` establishes a correspondence between `mapM f xs` and `mapM f' ys` under certain conditions.\n- Proof strategy: Use the definition of `corres_underlyingK` and the `corres_mapM` rule.\n- Unfold `corres_underlyingK_def` to work with its definition directly.\n- Apply `impI` to handle the implication in the goal.\n- Use `corres_mapM` rule with parameters `r`, `r'`, and `S` to establish the correspondence for `mapM`.\n- Show that the assumptions `S`, `z`, and `w` satisfy the preconditions required by `corres_mapM`.\n- Base case: When `xs` and `ys` are empty, verify that the initial state and relation `r [] []` hold.\n- Inductive step: Assume the correspondence holds for `xs` and `ys`, then extend it to `x # xs` and `y # ys` using the assumptions `z` and `w`.\n- Key tactics: Simplify using the definitions and assumptions, apply `corres_mapM` rule, and use induction where necessary.\n- Ensure that all conditions in `corres_mapM` are met by leveraging the given assumptions `S`, `z`, and `w`.", "cot_output": "```isabelle\nlemma corresK_mapM:\n  assumes S: \"set (zip xs ys) \\<subseteq> S\"\n  assumes z: \"\\<And>x y. corres_protect ((x, y) \\<in> S) \\<Longrightarrow> corres_underlyingK R nf nf' (F x y) r' P P' (f x) (f' y)\"\n  assumes w: \"\\<And>x y. (x, y) \\<in> S \\<Longrightarrow> \\<lbrace>P\\<rbrace> f x \\<lbrace>\\<lambda>rv. P\\<rbrace>\"\n             \"\\<And>x y. (x, y) \\<in> S \\<Longrightarrow> \\<lbrace>P'\\<rbrace> f' y \\<lbrace>\\<lambda>rv. P'\\<rbrace>\"\n  shows      \"corres_underlyingK R nf nf'\n                  ((length xs = length ys) \\<and>\n                   (r [] []) \\<and> (\\<forall>x xs y ys. r xs ys \\<longrightarrow> r' x y \\<longrightarrow> r (x # xs) (y # ys)) \\<and>\n                  (\\<forall>(x,y)\\<in>S. F x y)) r P P' (mapM f xs) (mapM f' ys)\"\n  unfolding corres_underlyingK_def\n  apply (rule impI)\n  apply (rule corres_mapM[of r r' S])\n  apply (simp add: S)\n  apply (clarsimp simp: Ball_def)\n  apply (drule_tac x=x and y=y in bspec, assumption)\n  apply (clarsimp simp: Ball_def)\n  apply (drule_tac x=x and y=y in bspec, assumption)\n  apply (clarsimp simp: Ball_def)\n  done\n```", "fs_baseline_output": "```isabelle\nlemma corresK_mapM:\n  assumes S: \"set (zip xs ys) \\<subseteq> S\"\n  assumes z: \"\\<And>x y. corres_protect ((x, y) \\<in> S) \\<Longrightarrow> corres_underlyingK R nf nf' (F x y) r' P P' (f x) (f' y)\"\n  assumes w: \"\\<And>x y. (x, y) \\<in> S \\<Longrightarrow> \\<lbrace>P\\<rbrace> f x \\<lbrace>\\<lambda>rv. P\\<rbrace>\"\n             \"\\<And>x y. (x, y) \\<in> S \\<Longrightarrow> \\<lbrace>P'\\<rbrace> f' y \\<lbrace>\\<lambda>rv. P'\\<rbrace>\"\n  shows      \"corres_underlyingK R nf nf'\n                  ((length xs = length ys) \\<and>\n                   (r [] []) \\<and> (\\<forall>x xs y ys. r xs ys \\<longrightarrow> r' x y \\<longrightarrow> r (x # xs) (y # ys)) \\<and>\n                  (\\<forall>(x,y)\\<in>S. F x y)) r P P' (mapM f xs) (mapM f' ys)\"\n  unfolding corres_underlyingK_def\n  apply (rule impI, rule corres_mapM[of r r' S])\n  apply (rule ballI, clarsimp)\n  apply (drule_tac x=x and y=y in bspec, assumption)\n  apply (clarsimp simp: zip_mapM)\n  apply (rule corres_guard_imp)\n   apply (rule corres_splitEE)\n     apply (rule corres_rel_imp)\n      apply (rule corres_underlyingK_lift)\n       apply (rule corres_underlyingK_assume_pre)\n       apply (rule z)\n      apply (clarsimp simp: corres_protect_def)\n     apply (rule corres_trivial)\n    apply (rule w)\n   apply (rule w)\n  apply simp\n  done\n```", "fs_cot_sketch": "- The lemma `corresK_mapM` aims to establish a correspondence between `mapM f xs` and `mapM f' ys` under certain conditions.\n- Proof strategy: Use the definition of `corres_underlyingK` and properties of `corres_mapM`.\n- Unfold `corres_underlyingK_def` to work with its definition directly.\n- Apply `impI` to handle the implication structure.\n- Use `corres_mapM` to relate `mapM f xs` and `mapM f' ys`:\n  - Show that the lengths of `xs` and `ys` are equal.\n  - Establish the initial condition `r [] []`.\n  - Prove the recursive condition: if `r xs ys` and `r' x y`, then `r (x # xs) (y # ys)`.\n  - Ensure that for all `(x, y) ∈ S`, `F x y` holds.\n- Leverage assumptions `S`, `z`, and `w` to justify each part of the `corres_mapM` conditions:\n  - `S` ensures that all pairs `(x, y)` from `zip xs ys` are in `S`.\n  - `z` provides the correspondence between `f x` and `f' y` for `(x, y) ∈ S`.\n  - `w` ensures that `f x` and `f' y` preserve their preconditions `P` and `P'` respectively.\n- Tactics: Use `unfold` to apply definitions, `apply` to introduce rules, and rely on assumptions to complete the proof.", "fs_cot_output": "```isabelle\nlemma corresK_mapM:\n  assumes S: \"set (zip xs ys) \\<subseteq> S\"\n  assumes z: \"\\<And>x y. corres_protect ((x, y) \\<in> S) \\<Longrightarrow> corres_underlyingK R nf nf' (F x y) r' P P' (f x) (f' y)\"\n  assumes w: \"\\<And>x y. (x, y) \\<in> S \\<Longrightarrow> \\<lbrace>P\\<rbrace> f x \\<lbrace>\\<lambda>rv. P\\<rbrace>\"\n             \"\\<And>x y. (x, y) \\<in> S \\<Longrightarrow> \\<lbrace>P'\\<rbrace> f' y \\<lbrace>\\<lambda>rv. P'\\<rbrace>\"\n  shows      \"corres_underlyingK R nf nf'\n                  ((length xs = length ys) \\<and>\n                   (r [] []) \\<and> (\\<forall>x xs y ys. r xs ys \\<longrightarrow> r' x y \\<longrightarrow> r (x # xs) (y # ys)) \\<and>\n                  (\\<forall>(x,y)\\<in>S. F x y)) r P P' (mapM f xs) (mapM f' ys)\"\n  unfolding corres_underlyingK_def\n  apply (rule impI)\n  apply (rule corres_mapM[of r r' S])\n  using assms\n  apply (auto intro: corres_guard_imp)\n  done\n```"}
{"input": "lemma F_all2_pointwise[simp]:\n  \"F_all2 (\\<lambda>x y _ _. F x y) xs ys = list_all2 F xs ys\"\n  apply (rule iffI)\n  apply (clarsimp simp: F_all2_def)\n  subgoal for F'\n  apply (rule list_all2_induct_suffixeq[where Q=F']; simp)\n  apply (drule_tac x=x in spec)\n  apply (drule_tac x=y in spec)\n  apply fastforce\n  done\n  apply (clarsimp simp:F_all2_def)\n  apply (rule_tac x=F in exI)\n  apply clarsimp\n  done\n\nlemma F_all2_list:\n   \"F xs ys \\<Longrightarrow> \\<exists>F'. (\\<forall>xs ys. (F xs ys = list_all2 F' xs ys)) \\<Longrightarrow> F_all2 (\\<lambda>_ _ xs ys. F xs ys) xs ys\"\n  apply (clarsimp simp: F_all2_def)\n  apply (rule_tac x=F' in exI)", "gt": "by auto", "baseline_output": "```isabelle\nlemma F_all2_list:\n   \"F xs ys \\<Longrightarrow> \\<exists>F'. (\\<forall>xs ys. (F xs ys = list_all2 F' xs ys)) \\<Longrightarrow> F_all2 (\\<lambda>_ _ xs ys. F xs ys) xs ys\"\n  apply (clarsimp simp: F_all2_def)\n  apply (rule_tac x=F' in exI)\n  apply clarsimp\n  done\n```", "cot_sketch": "- The lemma `F_all2_list` states that if `F xs ys` holds and there exists a function `F'` such that `F xs ys` is equivalent to `list_all2 F' xs ys`, then `F_all2` with a specific lambda function also holds.\n- Proof strategy: Use the given conditions to construct the required `F_all2` condition.\n- Step 1: Assume `F xs ys` and the existence of `F'` such that `F xs ys = list_all2 F' xs ys`.\n- Step 2: Introduce `F'` into the context using existential quantifier elimination.\n- Step 3: Show that `F_all2 (\\<lambda>_ _ xs ys. F xs ys) xs ys` holds by using the definition of `F_all2` and the assumption about `F'`.\n- Tactics: (clarsimp simp: F_all2_def; rule_tac x=F' in exI; clarsimp).", "cot_output": "```isabelle\nlemma F_all2_list:\n   \"F xs ys \\<Longrightarrow> \\<exists>F'. (\\<forall>xs ys. (F xs ys = list_all2 F' xs ys)) \\<Longrightarrow> F_all2 (\\<lambda>_ _ xs ys. F xs ys) xs ys\"\n  apply (clarsimp simp: F_all2_def)\n  apply (rule_tac x=F' in exI)\n  apply clarsimp\n  done\n```", "fs_baseline_output": "```isabelle\nlemma F_all2_pointwise[simp]:\n  \"F_all2 (\\<lambda>x y _ _. F x y) xs ys = list_all2 F xs ys\"\n  apply (rule iffI)\n  apply (clarsimp simp: F_all2_def)\n  subgoal for F'\n  apply (rule list_all2_induct_suffixeq[where Q=F']; simp)\n  apply (drule_tac x=x in spec)\n  apply (drule_tac x=y in spec)\n  apply fastforce\n  done\n  apply (clarsimp simp:F_all2_def)\n  apply (rule_tac x=F in exI)\n  apply clarsimp\n  done\n\nlemma F_all2_list:\n   \"F xs ys \\<Longrightarrow> \\<exists>F'. (\\<forall>xs ys. (F xs ys = list_all2 F' xs ys)) \\<Longrightarrow> F_all2 (\\<lambda>_ _ xs ys. F xs ys) xs ys\"\n  apply (clarsimp simp: F_all2_def)\n  apply (rule_tac x=F' in exI)\n  apply clarsimp\n  done\n```", "fs_cot_sketch": "- The lemma `F_all2_list` aims to show that if `F xs ys` holds and there exists a function `F'` such that `F xs ys` is equivalent to `list_all2 F' xs ys`, then `F_all2` with a specific predicate also holds.\n- Proof strategy: Direct proof using the given assumptions.\n- Step 1: Simplify the goal using the definition of `F_all2`.\n- Step 2: Introduce the witness function `F'` from the assumption.\n- Step 3: Show that the predicate `\\<lambda>_ _ xs ys. F xs ys` satisfies the condition required by `F_all2` using the introduced `F'`.\n- Tactics: (clarsimp simp: F_all2_def; rule_tac x=F' in exI; clarsimp).", "fs_cot_output": "```isabelle\nlemma F_all2_list:\n   \"F xs ys \\<Longrightarrow> \\<exists>F'. (\\<forall>xs ys. (F xs ys = list_all2 F' xs ys)) \\<Longrightarrow> F_all2 (\\<lambda>_ _ xs ys. F xs ys) xs ys\"\n  apply (clarsimp simp: F_all2_def)\n  apply (rule_tac x=F' in exI)\n  apply clarsimp\n  done\n```"}
{"input": "lemma list_all2_conjD:\n  \"list_all2 (\\<lambda>x y. Q x y \\<and> P x y) xs ys \\<Longrightarrow> list_all2 Q xs ys \\<and> list_all2 P xs ys\"", "gt": "by (induct rule: list_all2_induct; simp)", "baseline_output": "```isabelle\nlemma list_all2_conjD:\n  \"list_all2 (\\<lambda>x y. Q x y \\<and> P x y) xs ys \\<Longrightarrow> list_all2 Q xs ys \\<and> list_all2 P xs ys\"\n  by (auto simp: list_all2_conv_all_nth)\n```", "cot_sketch": "- The lemma states that if `list_all2` holds for a conjunction of predicates `Q` and `P`, then `list_all2` holds separately for each predicate `Q` and `P`.\n- Proof strategy: induction on the length of the lists `xs` and `ys`.\n- Base case: If `xs` and `ys` are empty lists, both sides of the implication simplify to `True`.\n- Inductive case: Assume `xs = x#xs'` and `ys = y#ys'`. Expand `list_all2` for both the premise and conclusion.\n  - Premise: `Q x y ∧ P x y ∧ list_all2 (\\<lambda>x y. Q x y ∧ P x y) xs' ys'`\n  - Conclusion: `Q x y ∧ list_all2 Q xs' ys' ∧ P x y ∧ list_all2 P xs' ys'`\n- Use the inductive hypothesis (IH) to show that `list_all2 Q xs' ys'` and `list_all2 P xs' ys'` hold.\n- Tactics: (induct xs ys rule: list_induct2; simp; conjI)\n- Simplify using logical equivalences and the properties of conjunction.", "cot_output": "```isabelle\nlemma list_all2_conjD:\n  \"list_all2 (\\<lambda>x y. Q x y \\<and> P x y) xs ys \\<Longrightarrow> list_all2 Q xs ys \\<and> list_all2 P xs ys\"\n  by (induct xs ys rule: list_induct2; simp; conjI)\n```", "fs_baseline_output": "```isabelle\nlemma list_all2_conjD:\n  \"list_all2 (\\<lambda>x y. Q x y \\<and> P x y) xs ys \\<Longrightarrow> list_all2 Q xs ys \\<and> list_all2 P xs ys\"\n  by (induct xs ys rule: list_all2_induct) auto\n```", "fs_cot_sketch": "- The lemma states that if `list_all2` holds for a conjunction of predicates `Q` and `P`, then `list_all2` holds separately for each predicate `Q` and `P`.\n- Proof strategy: induction on the length of the lists `xs` and `ys`.\n- Base case: If `xs` and `ys` are empty, both sides of the implication are trivially true.\n- Inductive case: Assume the lemma holds for lists of length `n`. Show it holds for lists of length `n+1`.\n  - Expand `list_all2` for the first elements and the rest of the lists.\n  - Use the inductive hypothesis to separate the predicates `Q` and `P` for the rest of the lists.\n  - Combine the results to show that `list_all2 Q xs ys` and `list_all2 P xs ys` hold.\n- Tactics: Use induction on the lists `xs` and `ys`, simplify using the definitions of `list_all2`, and apply the inductive hypothesis.", "fs_cot_output": "```isabelle\nlemma list_all2_conjD:\n  \"list_all2 (\\<lambda>x y. Q x y \\<and> P x y) xs ys \\<Longrightarrow> list_all2 Q xs ys \\<and> list_all2 P xs ys\"\nproof (induct xs ys rule: list_induct2)\n  case Nil_Nil\n  then show ?case by simp\nnext\n  case (Cons_Cons x y xs ys)\n  then have \"Q x y\" and \"P x y\" by simp_all\n  moreover have \"list_all2 Q xs ys \\<and> list_all2 P xs ys\" by (rule Cons_Cons.IH)\n  ultimately show ?case by simp\nqed\n```"}
{"input": "lemma\n  list_all2_to_list_all:\n  \"list_all2 P xs xs = list_all (\\<lambda>x. P x x) xs\"", "gt": "by (induct xs;simp)", "baseline_output": "```isabelle\nlemma list_all2_to_list_all:\n  \"list_all2 P xs xs = list_all (\\<lambda>x. P x x) xs\"\n  by (induct xs) (auto simp: list_all2_Cons)\n```", "cot_sketch": "- The lemma relates `list_all2` on identical lists with `list_all`.\n- Proof strategy: induction on `xs`.\n- Base case `xs = []`: both sides simplify to `True` because `list_all2` and `list_all` over an empty list are trivially true.\n- Inductive case `xs = y#ys`: expand `list_all2` and `list_all` for the non-empty list.\n  - `list_all2 P (y#ys) (y#ys)` can be expanded to `P y y ∧ list_all2 P ys ys`.\n  - `list_all (\\<lambda>x. P x x) (y#ys)` can be expanded to `P y y ∧ list_all (\\<lambda>x. P x x) ys`.\n- Show equivalence by induction hypothesis (IH): assume `list_all2 P ys ys = list_all (\\<lambda>x. P x x) ys`, then use this to prove the current step.\n- Tactics: (induct `xs`; simp).", "cot_output": "```isabelle\nlemma list_all2_to_list_all:\n  \"list_all2 P xs xs = list_all (\\<lambda>x. P x x) xs\"\n  by (induct xs; simp)\n```", "fs_baseline_output": "```isabelle\nlemma list_all2_to_list_all:\n  \"list_all2 P xs xs = list_all (\\<lambda>x. P x x) xs\"\n  by (induct xs) auto\n```", "fs_cot_sketch": "- The lemma relates `list_all2` on identical lists with `list_all`.\n- Proof strategy: induction on `xs`.\n- Base case `xs = []`: both sides simplify to `True` because `list_all2` on empty lists is `True` and `list_all` over an empty list is also `True`.\n- Inductive case `xs = y#ys`: expand `list_all2` and `list_all` for the non-empty list.\n  - `list_all2 P (y#ys) (y#ys)` simplifies to `P y y ∧ list_all2 P ys ys` by definition.\n  - `list_all (\\<lambda>x. P x x) (y#ys)` simplifies to `P y y ∧ list_all (\\<lambda>x. P x x) ys` by definition.\n  - Show equivalence by induction hypothesis (IH) on `ys`.\n- Tactics: Use induction on `xs`, then simplify using the definitions of `list_all2` and `list_all`.", "fs_cot_output": "```isabelle\nlemma list_all2_to_list_all:\n  \"list_all2 P xs xs = list_all (\\<lambda>x. P x x) xs\"\n  by (induct xs; simp)\n```"}
{"input": "lemma list_all_mem_subset:\n  \"list_all (\\<lambda>y. y \\<in> set xs) ys = (set ys \\<subseteq> set xs)\"", "gt": "by (induct ys; simp)", "baseline_output": "```isabelle\nlemma list_all_mem_subset:\n  \"list_all (\\<lambda>y. y \\<in> set xs) ys = (set ys \\<subseteq> set xs)\"\n  by (auto simp: list_all_iff subset_eq)\n```", "cot_sketch": "- The lemma states that all elements of list `ys` are members of the set of elements in list `xs` if and only if the set of elements in `ys` is a subset of the set of elements in `xs`.\n- Proof strategy: equivalence proof by showing both directions.\n  - Forward direction: Assume `list_all (\\<lambda>y. y \\<in> set xs) ys`, show `set ys \\<subseteq> set xs`.\n  - Backward direction: Assume `set ys \\<subseteq> set xs`, show `list_all (\\<lambda>y. y \\<in> set xs) ys`.\n- Forward direction:\n  - Assume `list_all (\\<lambda>y. y \\<in> set xs) ys`.\n  - By definition of `list_all`, for every element `y` in `ys`, `y` is in `set xs`.\n  - Therefore, every element of `set ys` is in `set xs`, which means `set ys \\<subseteq> set xs`.\n- Backward direction:\n  - Assume `set ys \\<subseteq> set xs`.\n  - By definition of subset, for every element `y` in `set ys`, `y` is in `set xs`.\n  - Since `ys` contains exactly the elements of `set ys`, every element `y` in `ys` is in `set xs`.\n  - Therefore, `list_all (\\<lambda>y. y \\<in> set xs) ys`.\n- Tactics: Use definitions of `list_all` and subset, and apply logical equivalences.", "cot_output": "```isabelle\nlemma list_all_mem_subset:\n  \"list_all (\\<lambda>y. y \\<in> set xs) ys = (set ys \\<subseteq> set xs)\"\nproof\n  assume \"list_all (\\<lambda>y. y \\<in> set xs) ys\"\n  thus \"set ys \\<subseteq> set xs\"\n    unfolding list_all_def by fastforce\nnext\n  assume \"set ys \\<subseteq> set xs\"\n  thus \"list_all (\\<lambda>y. y \\<in> set xs) ys\"\n    unfolding list_all_def by fastforce\nqed\n```", "fs_baseline_output": "```isabelle\nlemma list_all_mem_subset:\n  \"list_all (\\<lambda>y. y \\<in> set xs) ys = (set ys \\<subseteq> set xs)\"\n  by (auto simp: list_all_iff subset_iff)\n```", "fs_cot_sketch": "- The lemma states that all elements of list `ys` are in the set of elements of list `xs` if and only if the set of elements of `ys` is a subset of the set of elements of `xs`.\n- Proof strategy: Use set properties and definitions to establish the equivalence.\n- Show that if `list_all (\\<lambda>y. y \\<in> set xs) ys` holds, then every element of `ys` is in `set xs`, implying `set ys \\<subseteq> set xs`.\n- Conversely, show that if `set ys \\<subseteq> set xs` holds, then for every element `y` in `ys`, `y` is in `set xs`, which means `list_all (\\<lambda>y. y \\<in> set xs) ys` holds.\n- Key simplifications: Use the definition of `list_all` and set subset (`\\<subseteq>`), and apply logical equivalences.\n- Tactics: (unfold list_all_def; auto simp: subset_iff).", "fs_cot_output": "```isabelle\nlemma list_all_mem_subset:\n  \"list_all (\\<lambda>y. y \\<in> set xs) ys = (set ys \\<subseteq> set xs)\"\n  by (auto simp: list_all_def subset_iff)\n```"}
{"input": "lemma F_all2_eq:\n  \"(\\<And>x xs'. x \\<in> set xs \\<Longrightarrow> set xs' \\<subseteq> set xs \\<Longrightarrow> F x x xs' xs') \\Longrightarrow> F_all2 F xs xs\"\n apply (simp add: F_all2_def)\n apply (rule_tac x=\"\\<lambda>x y. x \\<in> set xs \\<and> x = y\" in exI)\n apply (intro conjI impI allI)\n apply (drule list_all2_conjD)\n apply (simp add: list.rel_eq)\n apply (simp add: list_all2_to_list_all list_all_mem_subset)\n apply (rule list.rel_refl_strong;simp)\n done\n\nlemma F_all2_conjI:\n  \"F_all2 F xs ys \\<Longrightarrow> F_all2 F' xs ys \\<Longrightarrow>\n    F_all2 (\\<lambda>x y xs ys. F x y xs ys \\<and> F' x y xs ys) xs ys\"\n  apply (clarsimp simp: F_all2_def)\n  apply (rule_tac x=\"\\<lambda>x y. F'a x y \\<and> F'aa x y\" in exI)", "gt": "by (auto dest: list_all2_conjD intro: list_all2_conj)", "baseline_output": "```isabelle\nlemma F_all2_conjI:\n  \"F_all2 F xs ys \\<Longrightarrow> F_all2 F' xs ys \\<Longrightarrow>\n    F_all2 (\\<lambda>x y xs ys. F x y xs ys \\<and> F' x y xs ys) xs ys\"\n  apply (clarsimp simp: F_all2_def)\n  apply (rule_tac x=\"\\<lambda>x y. F x y xs ys \\<and> F' x y xs ys\" in exI)\n  apply (clarsimp simp: list_all2_conv_all_nth)\n  apply (erule_tac x=n in allE)+\n  apply simp\n  done\n```", "cot_sketch": "- The lemma `F_all2_conjI` states that if two predicates `F` and `F'` hold for all elements of lists `xs` and `ys` according to `F_all2`, then their conjunction also holds for all elements of these lists.\n- Proof strategy: Use the definition of `F_all2` to construct a witness function that satisfies the combined predicate.\n- Start by unfolding the definition of `F_all2` for both `F_all2 F xs ys` and `F_all2 F' xs ys`.\n- Introduce a witness function for the combined predicate using `exI` (existential introduction). The witness function should combine the witness functions from the premises.\n- Use `conjI` to introduce the conjunction of the two predicates.\n- Use `impI` to handle implications within the witness function.\n- Use `allI` to generalize over all elements in the lists.\n- Apply `drule` with `list_all2_conjD` to decompose the `list_all2` predicates into their respective components.\n- Simplify using `simp` to handle definitions and logical equivalences.\n- Tactics: (clarsimp simp: F_all2_def; rule_tac x=\"\\<lambda>x y. F'a x y \\<and> F'aa x y\" in exI; intro conjI impI allI; drule list_all2_conjD; simp)", "cot_output": "```isabelle\nlemma F_all2_conjI:\n  \"F_all2 F xs ys \\<Longrightarrow> F_all2 F' xs ys \\<Longrightarrow>\n    F_all2 (\\<lambda>x y xs ys. F x y xs ys \\<and> F' x y xs ys) xs ys\"\n  apply (clarsimp simp: F_all2_def)\n  apply (rule_tac x=\"\\<lambda>x y. F x y xs ys \\<and> F' x y xs ys\" in exI)\n  apply (intro conjI impI allI)\n  apply (drule list_all2_conjD)\n  apply (simp add: list.rel_eq)\n  apply (simp add: list_all2_to_list_all list_all_mem_subset)\n  apply (rule list.rel_refl_strong; simp)\n  done\n```", "fs_baseline_output": "```isabelle\nlemma F_all2_eq:\n  \"(\\<And>x xs'. x \\<in> set xs \\<Longrightarrow> set xs' \\<subseteq> set xs \\<Longrightarrow> F x x xs' xs') \\Longrightarrow> F_all2 F xs xs\"\n  by (simp add: F_all2_def) (rule_tac x=\"\\<lambda>x y. x \\<in> set xs \\<and> x = y\" in exI, intro conjI impI allI, drule list_all2_conjD, simp add: list.rel_eq, simp add: list_all2_to_list_all list_all_mem_subset, rule list.rel_refl_strong, simp)\n\nlemma F_all2_conjI:\n  \"F_all2 F xs ys \\<Longrightarrow> F_all2 F' xs ys \\<Longrightarrow>\n    F_all2 (\\<lambda>x y xs ys. F x y xs ys \\<and> F' x y xs ys) xs ys\"\n  by (clarsimp simp: F_all2_def) (rule_tac x=\"\\<lambda>x y. F x y xs ys \\<and> F' x y xs ys\" in exI, simp)\n```", "fs_cot_sketch": "- The lemma `F_all2_eq` establishes a condition under which `F_all2 F xs xs` holds true by constructing a suitable witness function.\n- Proof strategy: Use the definition of `F_all2` and construct a lambda function that satisfies the required properties.\n- Tactics: Simplify using `simp add: F_all2_def`, introduce existential quantifier with `exI`, and use conjunction and implication introduction with `conjI` and `impI`.\n- Show that the constructed lambda function meets the criteria by applying `list_all2_conjD` and simplifying with `simp add: list.rel_eq`, `list_all2_to_list_all`, and `list_all_mem_subset`.\n- Use `list.rel_refl_strong` to establish reflexivity of the list relation.\n\n- The lemma `F_all2_conjI` combines two `F_all2` predicates into one by constructing a new predicate that is the conjunction of the two original predicates.\n- Proof strategy: Use the definition of `F_all2` and construct a lambda function that combines the two predicates.\n- Tactics: Simplify using `simp add: F_all2_def`, introduce existential quantifier with `exI`, and use conjunction introduction with `conjI`.\n- Show that the constructed lambda function meets the criteria by applying the definitions and properties of `F_all2`.", "fs_cot_output": "```isabelle\nlemma F_all2_eq:\n  \"(\\<And>x xs'. x \\<in> set xs \\<Longrightarrow> set xs' \\<subseteq> set xs \\<Longrightarrow> F x x xs' xs') \\Longrightarrow> F_all2 F xs xs\"\n  by (simp add: F_all2_def) (rule_tac x=\"\\<lambda>x y. x \\<in> set xs \\<and> x = y\" in exI, intro conjI impI allI, drule list_all2_conjD, simp add: list.rel_eq, simp add: list_all2_to_list_all list_all_mem_subset, rule list.rel_refl_strong; simp)\n\nlemma F_all2_conjI:\n  \"F_all2 F xs ys \\<Longrightarrow> F_all2 F' xs ys \\<Longrightarrow>\n    F_all2 (\\<lambda>x y xs ys. F x y xs ys \\<and> F' x y xs ys) xs ys\"\n  by (clarsimp simp: F_all2_def) (rule_tac x=\"\\<lambda>x y. F x y xs ys \\<and> F' x y xs ys\" in exI, simp)\n```"}
{"input": "lemma corresK_mapM_list_all2:\n  assumes x: \"\\<And>x y xs ys. corres_underlyingK sr nf nf' (F x y xs ys) r' (I (x#xs)) (I' (y#ys)) (f x) (f' y)\"\n  assumes \"\\<And>x y xs. \\<lbrakk> S x y; suffix (x#xs) as \\rbrakk> \\Longrightarrow> \\<lbrace> I  (x#xs) \\<rbrace> f  x \\<lbrace> \\<lambda>rv. I  xs \\<rbrace>\"\n  assumes \"\\<And>x y ys. \\<lbrakk> S x y; suffix (y#ys) cs \\rbrakk> \\Longrightarrow> \\<lbrace> I' (y#ys) \\<rbrace> f' y \\<lbrace> \\<lambda>rv. I' ys \\<rbrace>\"\n  shows \"corres_underlyingK sr nf nf'\n          (r [] [] \\<and> (\\<forall> x y xs ys. r' x y \\longrightarrow> r xs ys \\longrightarrow> r (x # xs) (y # ys)) \\and>\n            list_all2 S as cs \\and> F_all2 F as cs)\n                            r (I as) (I' cs) (mapM f as) (mapM f' cs)\"\n  unfolding corres_underlyingK_def\n  apply (clarsimp simp: F_all2_def)\n  subgoal for F'\n  apply (rule corres_mapM_list_all2[of r r' \"\\<lambda>x y. S x y \\<and> F' x y\"]; (rule assms | assumption | clarsimp)?)\n  apply (rule x[THEN corresK_unlift])\n  apply (drule list_all2_conjD)\n  apply (clarsimp simp: assms | assumption)+\n  apply (rule list_all2_conj; simp)\n  done\n  done\n\nlemma corresK_discard_rv:\n  assumes A[corresK]: \"corres_underlyingK sr nf nf' F r' P P' a c\"\n  shows \"corres_underlyingK sr nf nf' F dc P P' (do x \\<leftarrow> a; return () od) (do x \\<leftarrow> c; return () od)\"", "gt": "by corresKsimp", "baseline_output": "```isabelle\nlemma corresK_discard_rv:\n  assumes A[corresK]: \"corres_underlyingK sr nf nf' F r' P P' a c\"\n  shows \"corres_underlyingK sr nf nf' F dc P P' (do x \\<leftarrow> a; return () od) (do x \\<leftarrow> c; return () od)\"\n  unfolding corres_underlyingK_def\n  by (clarsimp simp: bind_def return_def dc_def)\n```", "cot_sketch": "- The lemma `corresK_discard_rv` aims to show that if two actions `a` and `c` correspond under the relation `corres_underlyingK`, then discarding their results still maintains the correspondence.\n- Proof strategy: Use the given assumption `A[corresK]` to leverage the existing correspondence between `a` and `c`.\n- Key step: Transform the monadic actions `(do x <- a; return () od)` and `(do x <- c; return () od)` into forms that can directly use the assumption `A[corresK]`.\n- Tactics: \n  - Use the `corresK` assumption to establish the correspondence between `a` and `c`.\n  - Simplify the monadic actions to focus on the underlying computations without their results.\n  - Apply the `corresK_unlift` rule to discard the results of the actions.\n- Simplifications: \n  - Use `clarsimp` to simplify the monadic bind operations and return statements.\n  - Leverage the `corresK` assumption to show that the transformed actions maintain the correspondence relation.", "cot_output": "```isabelle\nlemma corresK_discard_rv:\n  assumes A[corresK]: \"corres_underlyingK sr nf nf' F r' P P' a c\"\n  shows \"corres_underlyingK sr nf nf' F dc P P' (do x \\<leftarrow> a; return () od) (do x \\<leftarrow> c; return () od)\"\n  unfolding corres_underlyingK_def\n  apply (clarsimp simp: bind_def return_def)\n  apply (rule corresK)\n  apply (rule corresK_unlift)\n  apply (rule A)\n  done\n```", "fs_baseline_output": "```isabelle\nlemma corresK_discard_rv:\n  assumes A[corresK]: \"corres_underlyingK sr nf nf' F r' P P' a c\"\n  shows \"corres_underlyingK sr nf nf' F dc P P' (do x \\<leftarrow> a; return () od) (do x \\<leftarrow> c; return () od)\"\n  unfolding corres_underlyingK_def\n  by (clarsimp simp: bind_def return_def dc_def)\n```", "fs_cot_sketch": "- The lemma `corresK_discard_rv` aims to show that if two actions `a` and `c` correspond under a relation `F`, then performing these actions and discarding their results also corresponds under the same relation.\n- Proof strategy: Use the existing correspondence between `a` and `c` and leverage the fact that discarding the result does not affect the correspondence.\n- Key steps:\n  - Start with the given correspondence `corres_underlyingK sr nf nf' F r' P P' a c`.\n  - Use the `corresK` assumption to establish that `a` and `c` have the same effect up to the relation `F`.\n  - Show that wrapping `a` and `c` in a monadic bind followed by `return ()` does not change the correspondence.\n  - Use the `corresK_unlift` rule to simplify the correspondence after discarding the result.\n- Tactics: \n  - Use the `corresK` assumption directly.\n  - Apply `corresK_unlift` to handle the `return ()` part.\n  - Simplify using the definitions and properties of monadic operations and correspondence relations.", "fs_cot_output": "```isabelle\nlemma corresK_discard_rv:\n  assumes A[corresK]: \"corres_underlyingK sr nf nf' F r' P P' a c\"\n  shows \"corres_underlyingK sr nf nf' F dc P P' (do x \\<leftarrow> a; return () od) (do x \\<leftarrow> c; return () od)\"\n  by (rule corresK_unlift[OF A], simp)\n```"}
{"input": "lemma corresK_mapM_mapM_x:\n  assumes \"corres_underlyingK sr nf nf' F r' P P' (mapM f as) (mapM f' cs)\"\n  shows \"corres_underlyingK sr nf nf' F dc P P' (mapM_x f as) (mapM_x f' cs)\"", "gt": "by (rule corresK_discard_rv, rule assms)", "baseline_output": "```isabelle\nlemma corresK_mapM_mapM_x:\n  assumes \"corres_underlyingK sr nf nf' F r' P P' (mapM f as) (mapM f' cs)\"\n  shows \"corres_underlyingK sr nf nf' F dc P P' (mapM_x f as) (mapM_x f' cs)\"\n  using assms\n  by (clarsimp simp: mapM_x_def mapM_def corres_underlyingK_def sequence_def sequence_x_def)\n```", "cot_sketch": "- The lemma aims to show that if `mapM` operations with functions `f` and `f'` over lists `as` and `cs` respectively correspond under `corres_underlyingK`, then the corresponding `mapM_x` operations also correspond under the same relation.\n- Proof strategy: induction on the list `as` (and by symmetry, `cs`).\n- Base case `as = []` and `cs = []`: Both `mapM` and `mapM_x` over empty lists result in a return of the initial state, thus the correspondence holds trivially.\n- Inductive case `as = a#as'` and `cs = c#cs'`: \n  - Expand `mapM` and `mapM_x` for the non-empty lists.\n  - Use the assumption `corres_underlyingK` for the first elements `a` and `c`.\n  - Apply the inductive hypothesis (IH) to show that the remaining lists `as'` and `cs'` maintain the correspondence.\n- Tactics: (induct as cs rule: list_induct2; simp; use assumption; apply IH).", "cot_output": "```isabelle\nlemma corresK_mapM_mapM_x:\n  assumes \"corres_underlyingK sr nf nf' F r' P P' (mapM f as) (mapM f' cs)\"\n  shows \"corres_underlyingK sr nf nf' F dc P P' (mapM_x f as) (mapM_x f' cs)\"\nproof (induct as cs rule: list_induct2)\n  case Nil_Nil\n  show ?case by simp\nnext\n  case (Cons_Cons a as' c cs')\n  have \"corres_underlyingK sr nf nf' F dc (P andalso (\\<lambda>s. nf s = Some a)) (P' andalso (\\<lambda>s'. nf' s' = Some c))\n          (do x \\<leftarrow> f a; mapM_x f as' od)\n          (do x' \\<leftarrow> f' c; mapM_x f' cs' od)\"\n    using Cons_Cons.prems\n    by (wpsimp wp: corres_underlyingK_bindE corres_underlyingK_returnOk)\n  thus ?case by simp\nqed\n```", "fs_baseline_output": "```isabelle\nlemma corresK_mapM_mapM_x:\n  assumes \"corres_underlyingK sr nf nf' F r' P P' (mapM f as) (mapM f' cs)\"\n  shows \"corres_underlyingK sr nf nf' F dc P P' (mapM_x f as) (mapM_x f' cs)\"\n  using assms\n  by (simp add: mapM_x_def mapM_def corres_underlyingK_def sequence_corres_underlyingK sequence_x_corres_underlyingK)\n```", "fs_cot_sketch": "- The lemma aims to show that if `mapM f as` corresponds to `mapM f' cs`, then `mapM_x f as` corresponds to `mapM_x f' cs`.\n- Proof strategy: Use the definition of `mapM_x` and `mapM` to relate their behaviors.\n- Key observation: `mapM_x` can be expressed in terms of `mapM` by discarding the results.\n- Step 1: Express `mapM_x f as` as `mapM f as` followed by discarding the result.\n- Step 2: Express `mapM_x f' cs` as `mapM f' cs` followed by discarding the result.\n- Step 3: Use the assumption that `mapM f as` corresponds to `mapM f' cs` to infer the correspondence between `mapM_x f as` and `mapM_x f' cs`.\n- Tactics: Unfold definitions of `mapM_x` and `mapM`, use the assumption, and apply correspondence rules for monadic operations.\n- Simplification: Simplify the expressions involving `mapM` and `mapM_x` to show that the correspondence holds after discarding results.", "fs_cot_output": "```isabelle\nlemma corresK_mapM_mapM_x:\n  assumes \"corres_underlyingK sr nf nf' F r' P P' (mapM f as) (mapM f' cs)\"\n  shows \"corres_underlyingK sr nf nf' F dc P P' (mapM_x f as) (mapM_x f' cs)\"\n  unfolding mapM_x_def mapM_def\n  by (rule corresK_bind_ignore_rhs[OF assms corresK_return_ignore])\n```"}
{"input": "lemma corresK_subst_both: \"g' = f' \\<Longrightarrow> g = f \\<Longrightarrow>\n  corres_underlyingK sr nf nf' F r P P' f f' \\<Longrightarrow>", "gt": "by simp", "baseline_output": "```isabelle\nlemma corresK_subst_both: \"g' = f' \\<Longrightarrow> g = f \\<Longrightarrow>\n  corres_underlyingK sr nf nf' F r P P' f f' \\<Longrightarrow>\n  corres_underlyingK sr nf nf' F r P P' g g'\"\n  by simp\n```", "cot_sketch": "- The lemma states that if two functions `g'` and `f'` are equal, and two other functions `g` and `f` are equal, then substituting these equal functions into a correspondence relation `corres_underlyingK` preserves the relation.\n- Proof strategy: Direct substitution and simplification using the given equalities.\n- Step 1: Use the assumption `g' = f'` to substitute `f'` for `g'` in the `corres_underlyingK` relation.\n- Step 2: Use the assumption `g = f` to substitute `f` for `g` in the `corres_underlyingK` relation.\n- Step 3: Simplify the resulting expression to show that the original and substituted relations are equivalent.\n- Tactics: (simp add: assms).", "cot_output": "```isabelle\nlemma corresK_subst_both: \"g' = f' \\<Longrightarrow> g = f \\<Longrightarrow>\n  corres_underlyingK sr nf nf' F r P P' f f' \\<Longrightarrow>\n  corres_underlyingK sr nf nf' F r P P' g g'\"\n  by (simp add: assms)\n```", "fs_baseline_output": "```isabelle\nlemma corresK_subst_both: \"g' = f' \\<Longrightarrow> g = f \\<Longrightarrow>\n  corres_underlyingK sr nf nf' F r P P' f f' \\<Longrightarrow>\n  corres_underlyingK sr nf nf' F r P P' g g'\"\n  by simp\n```", "fs_cot_sketch": "- The lemma states that if two functions `g` and `g'` are equal, and another pair of functions `f` and `f'` are equal, then substituting these equal functions into a correspondence relation `corres_underlyingK` preserves the relation.\n- Proof strategy: Direct substitution and simplification using the given equalities.\n- Step 1: Use the equality `g' = f'` to replace `g'` with `f'` in the `corres_underlyingK` relation.\n- Step 2: Use the equality `g = f` to replace `g` with `f` in the `corres_underlyingK` relation.\n- Step 3: Simplify the resulting expression to show that the original and substituted relations are equivalent.\n- Tactics: (simp add: given equalities).", "fs_cot_output": "```isabelle\nlemma corresK_subst_both: \"g' = f' \\<Longrightarrow> g = f \\<Longrightarrow>\n  corres_underlyingK sr nf nf' F r P P' f f' \\<Longrightarrow>\n  corres_underlyingK sr nf nf' F r P P' g g'\"\n  by (simp add: fun_eq_iff)\n```"}
