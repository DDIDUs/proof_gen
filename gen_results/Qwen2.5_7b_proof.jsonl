{"input": "lemma corres_throwError_str [corresK_concrete_rER]:\n  \"corres_underlyingK sr nf nf' (r (Inl a) (Inl b)) r \\<top> \\<top> (throwError a) (throw b)\"\n  \"corres_underlyingK sr nf nf' (r (Inl a) (Inl b)) r \\<top> \\<top> (throwError a) (throwError b)\"", "gt": "by (simp add: corres_underlyingK_def)+", "baseline_output": "```isabelle\nlemma corres_throwError_str [corresK_concrete_rER]:\n  \"corres_underlyingK sr nf nf' (r (Inl a) (Inl b)) r \\<top> \\<top> (throwError a) (throw b)\"\n  \"corres_underlyingK sr nf nf' (r (Inl a) (Inl b)) r \\<top> \\<top> (throwError a) (throwError b)\"\n  unfolding throwError_def throw_def\n  by (wpsimp wp: throwError_corres)\n```", "cot_sketch": "- The lemmas relate correspondence properties for throwError operations.\n- Proof strategy: induction on the structure of the throwError operation.\n- Base case: throwError a corresponds to throwError a trivially.\n- Inductive case: consider throwError a followed by another operation.\n- Tactics: (induct rule: throwError.induct; simp).", "cot_output": "```isabelle\nlemma corres_throwError_str [corresK_concrete_rER]:\n  \"corres_underlyingK sr nf nf' (r (Inl a) (Inl b)) r \\<top> \\<top> (throwError a) (throw b)\"\n  \"corres_underlyingK sr nf nf' (r (Inl a) (Inl b)) r \\<top> \\<top> (throwError a) (throwError b)\"\nproof -\n  show \"corres_underlyingK sr nf nf' (r (Inl a) (Inl b)) r \\<top> \\<top> (throwError a) (throw b)\"\n    by (induct rule: throwError.induct; simp)\n  show \"corres_underlyingK sr nf nf' (r (Inl a) (Inl b)) r \\<top> \\<top> (throwError a) (throwError b)\"\n    by (induct rule: throwError.induct; simp)\nqed\n```", "fs_baseline_output": "```isabelle\nlemma corres_throwError_str [corresK_concrete_rER]:\n  \"corres_underlyingK sr nf nf' (r (Inl a) (Inl b)) r \\<top> \\<top> (throwError a) (throw b)\"\n  \"corres_underlyingK sr nf nf' (r (Inl a) (Inl b)) r \\<top> \\<top> (throwError a) (throwError b)\"\n  by (auto simp: throwError_def corres_underlyingK_def)\n```", "fs_cot_sketch": "- The lemmas relate two forms of correspondence for throwing errors.\n- Proof strategy: direct application of the definition of `corres_underlyingK`.\n- Key observation: `throwError` and `throw` are functions that map values to specific error results.\n- Simplification: Both sides of the equation simplify directly based on the definitions of `throwError` and `throw`, showing they produce equivalent results under the given conditions.\n- Tactics: (simplify).", "fs_cot_output": "```isabelle\nlemma corres_throwError_str [corresK_concrete_rER]:\n  \"corres_underlyingK sr nf nf' (r (Inl a) (Inl b)) r \\<top> \\<top> (throwError a) (throw b)\"\n  \"corres_underlyingK sr nf nf' (r (Inl a) (Inl b)) r \\<top> \\<top> (throwError a) (throwError b)\"\n  by (simplify)\n```"}
{"input": "lemma corresK_use_guard:\n  \"(F \\<Longrightarrow> corres_underlyingK sr nf nf' F r Q Q' f g) \\<Longrightarrow> corres_underlyingK sr nf nf' F r Q Q' f g\"", "gt": "by (simp add: corres_underlyingK_def)", "baseline_output": "```isabelle\nlemma corresK_use_guard:\n  \"(F \\<Longrightarrow> corres_underlyingK sr nf nf' F r Q Q' f g) \\<Longrightarrow> corres_underlyingK sr nf nf' F r Q Q' f g\"\n  by simp\n```", "cot_sketch": "- The lemma states that if `corres_underlyingK` holds under some condition `F`, then it also holds without any additional conditions.\n- Proof strategy: direct application of the definition of `corres_underlyingK`.\n- Key observation: the condition `F` is already part of the premise, so it trivially implies itself.\n- Tactics: (smp).", "cot_output": "```isabelle\nlemma corresK_use_guard:\n  \"(F \\<Longrightarrow> corres_underlyingK sr nf nf' F r Q Q' f g) \\<Longrightarrow> corres_underlyingK sr nf nf' F r Q Q' f g\"\n  by simp\n```", "fs_baseline_output": "```isabelle\nlemma corresK_use_guard:\n  \"(F \\<Longrightarrow> corres_underlyingK sr nf nf' F r Q Q' f g) \\<Longrightarrow> corres_underlyingK sr nf nf' F r Q Q' f g\"\n  by simp\n```", "fs_cot_sketch": "- The lemma states that if a correspondence holds under a guard F, then it also holds without the guard F.\n- Proof strategy: direct simplification using the definition of `corres_underlyingK`.\n- Simplify the right-hand side of the implication by removing the redundant guard F.\n- Tactics: (simplify).", "fs_cot_output": "```isabelle\nlemma corresK_use_guard:\n  \"(F \\<Longrightarrow> corres_underlyingK sr nf nf' F r Q Q' f g) \\<Longrightarrow> corres_underlyingK sr nf nf' F r Q Q' f g\"\n  by (simplify)\n```"}
{"input": "lemma corresK_mapM:\n  assumes S: \"set (zip xs ys) \\<subseteq> S\"\n  assumes z: \"\\<And>x y. corres_protect ((x, y) \\<in> S) \\<Longrightarrow> corres_underlyingK R nf nf' (F x y) r' P P' (f x) (f' y)\"\n  assumes w: \"\\<And>x y. (x, y) \\<in> S \\<Longrightarrow> \\<lbrace>P\\<rbrace> f x \\<lbrace>\\<lambda>rv. P\\<rbrace>\"\n             \"\\<And>x y. (x, y) \\<in> S \\<Longrightarrow> \\<lbrace>P'\\<rbrace> f' y \\<lbrace>\\<lambda>rv. P'\\<rbrace>\"\n  shows      \"corres_underlyingK R nf nf'\n                  ((length xs = length ys) \\<and>\n                   (r [] []) \\<and> (\\<forall>x xs y ys. r xs ys \\<longrightarrow> r' x y \\<longrightarrow> r (x # xs) (y # ys)) \\<and>\n                  (\\<forall>(x,y)\\<in>S. F x y)) r P P' (mapM f xs) (mapM f' ys)\"\n  unfolding corres_underlyingK_def\n  apply (rule impI, rule corres_mapM[of r r' S])", "gt": "by (auto simp: corres_protect_def)", "baseline_output": "```isabelle\nlemma corresK_mapM:\n  assumes S: \"set (zip xs ys) \\<subseteq> S\"\n  assumes z: \"\\<And>x y. corres_protect ((x, y) \\<in> S) \\<Longrightarrow> corres_underlyingK R nf nf' (F x y) r' P P' (f x) (f' y)\"\n  assumes w: \"\\<And>x y. (x, y) \\<in> S \\<Longrightarrow> \\<lbrace>P\\<rbrace> f x \\<lbrace>\\<lambda>rv. P\\<rbrace>\"\n             \"\\<And>x y. (x, y) \\<in> S \\<Longrightarrow> \\<lbrace>P'\\<rbrace> f' y \\<lbrace>\\<lambda>rv. P'\\<rbrace>\"\n  shows      \"corres_underlyingK R nf nf'\n                  ((length xs = length ys) \\<and>\n                   (r [] []) \\<and> (\\<forall>x xs y ys. r xs ys \\<longrightarrow> r' x y \\<longrightarrow> r (x # xs) (y # ys)) \\<and>\n                  (\\<forall>(x,y)\\<in>S. F x y)) r P P' (mapM f xs) (mapM f' ys)\"\n  unfolding corres_underlyingK_def\n  apply (rule impI, rule corres_mapM[of r r' S])\n  using S z w\n  by simp_all\n```", "cot_sketch": "- The lemma establishes correspondence for `mapM` under certain conditions.\n- Proof strategy: use the `corres_mapM` theorem from the library.\n- Key assumptions:\n  - `S`: Set condition for pairs `(x, y)` in `zip xs ys`.\n  - `z`: Correspondence property for elements `(x, y)` in `S`.\n  - `w`: Preservation of properties `P` and `P'` for elements `(x, y)` in `S`.\n- Unfold `corres_underlyingK_def` to simplify the goal.\n- Apply `impI` to introduce implication.\n- Apply `corres_mapM` with parameters `r`, `r'`, and `S` to handle the main correspondence.\n- Tactics: (unfolding corres_underlyingK_def; rule impI; rule corres_mapM).", "cot_output": "```isabelle\nlemma corresK_mapM:\n  assumes S: \"set (zip xs ys) \\<subseteq> S\"\n  assumes z: \"\\<And>x y. corres_protect ((x, y) \\<in> S) \\<Longrightarrow> corres_underlyingK R nf nf' (F x y) r' P P' (f x) (f' y)\"\n  assumes w: \"\\<And>x y. (x, y) \\<in> S \\<Longrightarrow> \\<lbrace>P\\<rbrace> f x \\<lbrace>\\<lambda>rv. P\\<rbrace>\"\n             \"\\<And>x y. (x, y) \\<in> S \\<Longrightarrow> \\<lbrace>P'\\<rbrace> f' y \\<lbrace>\\<lambda>rv. P'\\<rbrace>\"\n  shows      \"corres_underlyingK R nf nf'\n                  ((length xs = length ys) \\<and>\n                   (r [] []) \\<and> (\\<forall>x xs y ys. r xs ys \\<longrightarrow> r' x y \\<longrightarrow> r (x # xs) (y # ys)) \\<and>\n                  (\\<forall>(x,y)\\<in>S. F x y)) r P P' (mapM f xs) (mapM f' ys)\"\n  unfolding corres_underlyingK_def\n  apply (rule impI, rule corres_mapM[of r r' S])\n  done\n```", "fs_baseline_output": "```isabelle\nlemma corresK_mapM:\n  assumes S: \"set (zip xs ys) \\<subseteq> S\"\n  assumes z: \"\\<And>x y. corres_protect ((x, y) \\<in> S) \\<Longrightarrow> corres_underlyingK R nf nf' (F x y) r' P P' (f x) (f' y)\"\n  assumes w: \"\\<And>x y. (x, y) \\<in> S \\<Longrightarrow> \\<lbrace>P\\<rbrace> f x \\<lbrace>\\<lambda>rv. P\\<rbrace>\"\n             \"\\<And>x y. (x, y) \\<in> S \\<Longrightarrow> \\<lbrace>P'\\<rbrace> f' y \\<lbrace>\\<lambda>rv. P'\\<rbrace>\"\n  shows      \"corres_underlyingK R nf nf'\n                  ((length xs = length ys) \\<and>\n                   (r [] []) \\<and> (\\<forall>x xs y ys. r xs ys \\<longrightarrow> r' x y \\<longrightarrow> r (x # xs) (y # ys)) \\<and>\n                  (\\<forall>(x,y)\\<in>S. F x y)) r P P' (mapM f xs) (mapM f' ys)\"\n  unfolding corres_underlyingK_def\n  apply (rule impI, rule corres_mapM[of r r' S])\n  using S z w\n  by simp_all\n```", "fs_cot_sketch": "- The lemma states that if two functions `f` and `f'` correspond under certain conditions for pairs `(x, y)` in set `S`, then their compositions over lists `xs` and `ys` also correspond.\n- Proof strategy: use the definition of `corres_underlyingK` and apply the `corres_mapM` theorem.\n- Key assumptions:\n  - `S` is a subset of the set of pairs `(x, y)`.\n  - `z` ensures that for each pair `(x, y) \\in S`, the functions `F x y` correspond under `R`, `nf`, and `nf'`.\n  - `w` ensures that `f` and `f'` preserve the predicates `P` and `P'` respectively for all pairs `(x, y) \\in S`.\n- Apply `corres_mapM` to conclude the correspondence for `mapM f xs` and `mapM f' ys`.\n\nThis completes the reasoning chain for the given lemma.", "fs_cot_output": "```isabelle\nlemma corresK_mapM:\n  assumes S: \"set (zip xs ys) \\<subseteq> S\"\n  assumes z: \"\\<And>x y. corres_protect ((x, y) \\<in> S) \\<Longrightarrow> corres_underlyingK R nf nf' (F x y) r' P P' (f x) (f' y)\"\n  assumes w: \"\\<And>x y. (x, y) \\<in> S \\<Longrightarrow> \\<lbrace>P\\<rbrace> f x \\<lbrace>\\<lambda>rv. P\\<rbrace>\"\n             \"\\<And>x y. (x, y) \\<in> S \\<Longrightarrow> \\<lbrace>P'\\<rbrace> f' y \\<lbrace>\\<lambda>rv. P'\\<rbrace>\"\n  shows      \"corres_underlyingK R nf nf'\n                  ((length xs = length ys) \\<and>\n                   (r [] []) \\<and> (\\<forall>x xs y ys. r xs ys \\<longrightarrow> r' x y \\<longrightarrow> r (x # xs) (y # ys)) \\<and>\n                  (\\<forall>(x,y)\\<in>S. F x y)) r P P' (mapM f xs) (mapM f' ys)\"\n  unfolding corres_underlyingK_def\n  apply (rule impI, rule corres_mapM[of r r' S])\n  using S z w\n  by simp\n```"}
{"input": "lemma F_all2_pointwise[simp]:\n  \"F_all2 (\\<lambda>x y _ _. F x y) xs ys = list_all2 F xs ys\"\n  apply (rule iffI)\n  apply (clarsimp simp: F_all2_def)\n  subgoal for F'\n  apply (rule list_all2_induct_suffixeq[where Q=F']; simp)\n  apply (drule_tac x=x in spec)\n  apply (drule_tac x=y in spec)\n  apply fastforce\n  done\n  apply (clarsimp simp:F_all2_def)\n  apply (rule_tac x=F in exI)\n  apply clarsimp\n  done\n\nlemma F_all2_list:\n   \"F xs ys \\<Longrightarrow> \\<exists>F'. (\\<forall>xs ys. (F xs ys = list_all2 F' xs ys)) \\<Longrightarrow> F_all2 (\\<lambda>_ _ xs ys. F xs ys) xs ys\"\n  apply (clarsimp simp: F_all2_def)\n  apply (rule_tac x=F' in exI)", "gt": "by auto", "baseline_output": "```isabelle\nlemma F_all2_pointwise[simp]:\n  \"F_all2 (\\<lambda>x y _ _. F x y) xs ys = list_all2 F xs ys\"\n  apply (rule iffI)\n  apply (clarsimp simp: F_all2_def)\n  subgoal for F'\n  apply (rule list_all2_induct_suffixeq[where Q=F']); simp\n  apply (drule_tac x=x in spec)\n  apply (drule_tac x=y in spec)\n  apply fastforce\n  done\n  apply (clarsimp simp:F_all2_def)\n  apply (rule_tac x=F in exI)\n  apply clarsimp\n  done\n\nlemma F_all2_list:\n   \"F xs ys \\<Longrightarrow> \\<exists>F'. (\\<forall>xs ys. (F xs ys = list_all2 F' xs ys)) \\<Longrightarrow> F_all2 (\\<lambda>_ _ xs ys. F xs ys) xs ys\"\n  apply (clarsimp simp: F_all2_def)\n  apply (rule_tac x=F' in exI)\n```", "cot_sketch": "- The lemma states that if `F` satisfies certain properties, then there exists a function `F'` such that `F_all2` can be expressed using `list_all2`.\n- Proof strategy: use `clarsimp` to simplify the goal and introduce an existential quantifier for `F'`.\n- Key steps:\n  - Apply `clarsimp` to simplify the goal involving `F_all2`.\n  - Use `rule_tac x=F' in exI` to introduce `F'` as the solution.\n- Tactics: `clarsimp simp: F_all2_def`, `rule_tac x=F' in exI`.", "cot_output": "```isabelle\nlemma F_all2_list:\n   \"F xs ys \\<Longrightarrow> \\<exists>F'. (\\<forall>xs ys. (F xs ys = list_all2 F' xs ys)) \\<Longrightarrow> F_all2 (\\<lambda>_ _ xs ys. F xs ys) xs ys\"\n  apply (clarsimp simp: F_all2_def)\n  apply (rule_tac x=F' in exI)\n  done\n```", "fs_baseline_output": "```isabelle\nlemma F_all2_list:\n   \"F xs ys \\<Longrightarrow> \\<exists>F'. (\\<forall>xs ys. (F xs ys = list_all2 F' xs ys)) \\<Longrightarrow> F_all2 (\\<lambda>_ _ xs ys. F xs ys) xs ys\"\n  apply (clarsimp simp: F_all2_def)\n  apply (rule_tac x=F' in exI)\n  done\n```", "fs_cot_sketch": "- The lemmas relate F_all2 to list_all2 and F_all2 to a more general form.\n- Proof strategy: split into two parts using `apply (rule iffI)` to handle both directions of the equivalence.\n- For the forward direction (`apply (clarsimp simp: F_all2_def)`), use induction on suffixes of xs and ys to show equivalence.\n- For the backward direction (`apply (clarsimp simp:F_all2_def)`), introduce an arbitrary F' and show its existence.\n- Key tactics: `clarsimp`, `rule list_all2_induct_suffixeq`, `drule_tac`, `fastforce`.\n- The second lemma asserts the existence of a function F' such that F is equivalent to list_all2 F' under certain conditions.\n- Proof strategy: clarsimp the definition and introduce F' as an existential witness.\n- Key tactics: `clarsimp`, `rule_tac x=F' in exI`.", "fs_cot_output": "```isabelle\nlemma F_all2_pointwise[simp]:\n  \"F_all2 (\\<lambda>x y _ _. F x y) xs ys = list_all2 F xs ys\"\n  apply (rule iffI)\n  apply (clarsimp simp: F_all2_def)\n  subgoal for F'\n  apply (rule list_all2_induct_suffixeq[where Q=F']); simp\n  apply (drule_tac x=x in spec)\n  apply (drule_tac x=y in spec)\n  apply fastforce\n  done\n  apply (clarsimp simp:F_all2_def)\n  apply (rule_tac x=F in exI)\n  apply clarsimp\n  done\n\nlemma F_all2_list:\n   \"F xs ys \\<Longrightarrow> \\<exists>F'. (\\<forall>xs ys. (F xs ys = list_all2 F' xs ys)) \\<Longrightarrow> F_all2 (\\<lambda>_ _ xs ys. F xs ys) xs ys\"\n  apply (clarsimp simp: F_all2_def)\n  apply (rule_tac x=F' in exI)\n```"}
{"input": "lemma list_all2_conjD:\n  \"list_all2 (\\<lambda>x y. Q x y \\<and> P x y) xs ys \\<Longrightarrow> list_all2 Q xs ys \\<and> list_all2 P xs ys\"", "gt": "by (induct rule: list_all2_induct; simp)", "baseline_output": "```isabelle\nlemma list_all2_conjD:\n  \"list_all2 (\\<lambda>x y. Q x y \\<and> P x y) xs ys \\<Longrightarrow> list_all2 Q xs ys \\<and> list_all2 P xs ys\"\n  by (auto simp add: list_all2_conv_all_nth)\n```", "cot_sketch": "- The lemma states that if two lists satisfy a conjunction of predicates, then each list satisfies each predicate individually.\n- Proof strategy: induction on xs and ys simultaneously using `list_all2.induct`.\n- Base case xs = [] and ys = []: both sides simplify to True.\n- Inductive case xs = y#ys and ys = z#zs: \n  - Show that `Q y z` and `P y z` hold from the assumption.\n  - Use IH to conclude that `list_all2 Q (y#ys) (z#zs)` and `list_all2 P (y#ys) (z#zs)` hold.\n- Tactics: (`list_all2.induct; simp; assume; simp; blast`).", "cot_output": "```isabelle\nlemma list_all2_conjD:\n  \"list_all2 (\\<lambda>x y. Q x y \\<and> P x y) xs ys \\<Longrightarrow> list_all2 Q xs ys \\<and> list_all2 P xs ys\"\nproof (induct xs ys arbitrary: Q P rule: list_all2.induct)\n  case NilNil thus ?case by simp\nnext\n  case (ConsCons y ys z zs)\n  have \"Q y z\" and \"P y z\" using ConsCons.hyps by simp_all\n  with ConsCons.IH show ?case by blast\nqed\n```", "fs_baseline_output": "```isabelle\nlemma list_all2_conjD:\n  \"list_all2 (\\<lambda>x y. Q x y \\<and> P x y) xs ys \\<Longrightarrow> list_all2 Q xs ys \\<and> list_all2 P xs ys\"\n  by (auto simp: list_all2_def)\n```", "fs_cot_sketch": "- The lemma asserts that if all pairs of elements from two lists satisfy a conjunction of predicates, then each list satisfies the individual predicates.\n- Proof strategy: induction on xs and ys simultaneously.\n- Base case xs = [] and ys = []: both sides simplify to True.\n- Inductive case xs = y#ys and ys = z#zs: expand list_all2 for both sides, use the inductive hypothesis (IH) to show that the conjunction holds for the tails, and verify that the heads also satisfy the individual predicates.\n- Tactics: (induct xs ys; simp; blast).", "fs_cot_output": "```isabelle\nlemma list_all2_conjD:\n  \"list_all2 (\\<lambda>x y. Q x y \\<and> P x y) xs ys \\<Longrightarrow> list_all2 Q xs ys \\<and> list_all2 P xs ys\"\n  by (induct xs ys; simp; blast)\n```"}
{"input": "lemma\n  list_all2_to_list_all:\n  \"list_all2 P xs xs = list_all (\\<lambda>x. P x x) xs\"", "gt": "by (induct xs;simp)", "baseline_output": "```isabelle\nlemma list_all2_to_list_all:\n  \"list_all2 P xs xs = list_all (\\<lambda>x. P x x) xs\"\n  by (induct xs arbitrary: ys) simp_all\n```", "cot_sketch": "- The lemma states that `list_all2 P xs xs` is equivalent to `list_all (λx. P x x) xs`.\n- Proof strategy: induction on `xs`.\n- Base case `xs = []`: Both sides simplify to `True`, so the lemma holds trivially.\n- Inductive case `xs = y#ys`: \n  - Expand `list_all2 P xs xs` to `P y y \\<and> list_all2 P ys ys`.\n  - Expand `list_all (λx. P x x) xs` to `P y y \\<and> list_all (λx. P x x) ys`.\n  - Show that these two expressions are equivalent by using the induction hypothesis (IH) for `list_all2 P ys ys` and `list_all (λx. P x x) ys`.\n- Tactics: `(induct xs; simp; rule conjI; assumption)`.", "cot_output": "```isabelle\nlemma list_all2_to_list_all:\n  \"list_all2 P xs xs = list_all (λx. P x x) xs\"\nproof (induct xs)\n  case Nil\n  show ?case by simp\nnext\n  case (Cons y ys)\n  have \"list_all2 P xs xs = P y y \\<and> list_all2 P ys ys\" by simp\n  also have \"list_all (λx. P x x) xs = P y y \\<and> list_all (λx. P x x) ys\" by simp\n  finally show ?case by simp\nqed\n```", "fs_baseline_output": "```isabelle\nlemma list_all2_to_list_all:\n  \"list_all2 P xs ys = list_all (\\<lambda>x y. P x y) xs\"\n  by (induct xs ys rule: list_all2.induct) simp_all\n```", "fs_cot_sketch": "- The lemma states that `list_all2 P xs xs` is equivalent to `list_all (λx. P x x) xs`.\n- Proof strategy: induction on `xs`.\n- Base case `xs = []`: Both sides simplify to `True`, so the lemma holds trivially.\n- Inductive case `xs = y#ys`: \n  - Expand `list_all2 P xs xs` to `P y y \\<and> list_all2 P ys ys`.\n  - Expand `list_all (λx. P x x) xs` to `P y y \\<and> list_all (λx. P x x) ys`.\n  - Show that these two expressions are equivalent by applying the induction hypothesis (IH) to `list_all2 P ys ys`.\n- Tactics: `(induct xs; simp; rule IH)`", "fs_cot_output": "```isabelle\nlemma list_all2_to_list_all:\n  \"list_all2 P xs xs = list_all (λx. P x x) xs\"\n  by (induct xs; simp; rule IH)\n```"}
{"input": "lemma list_all_mem_subset:\n  \"list_all (\\<lambda>y. y \\<in> set xs) ys = (set ys \\<subseteq> set xs)\"", "gt": "by (induct ys; simp)", "baseline_output": "```isabelle\nlemma list_all_mem_subset:\n  \"list_all (\\<lambda>y. y \\<in> set xs) ys = (set ys \\<subseteq> set xs)\"\n  by (induct ys arbitrary: xs) (auto simp: subset_insertI list_all_def)\n```", "cot_sketch": "- The lemma states that `list_all` for membership in `xs` is equivalent to `set ys` being a subset of `set xs`.\n- Proof strategy: induction on `ys`.\n- Base case `ys = []`: both sides simplify to `True`, since the empty set is a subset of any set.\n- Inductive case `ys = z#zs`: \n  - Show that if all elements of `z#zs` are in `xs`, then `z` is in `xs` and all elements of `zs` are in `xs`.\n  - Use `list_all` definition and `subset_insertI` to prove the forward direction.\n  - Use `subset_insertD` and `list_all` definition to prove the reverse direction.\n- Tactics: (induct ys; simp; blast).", "cot_output": "```isabelle\nlemma list_all_mem_subset:\n  \"list_all (\\<lambda>y. y \\<in> set xs) ys = (set ys \\<subseteq> set xs)\"\nproof (induct ys)\n  case Nil\n  show ?case by simp\nnext\n  case (Cons z zs)\n  show ?case\n  proof\n    assume \"list_all (\\<lambda>y. y \\<in> set xs) (z # zs)\"\n    then have \"z \\<in> set xs\" and \"list_all (\\<lambda>y. y \\<in> set xs) zs\" by simp_all\n    thus \"z \\<in> set xs \\<and> set zs \\<subseteq> set xs\" by simp\n  next\n    assume \"z \\<in> set xs \\<and> set zs \\<subseteq> set xs\"\n    hence \"list_all (\\<lambda>y. y \\<in> set xs) zs\" by simp\n    moreover have \"z \\<in> set xs\" by fact\n    ultimately show \"list_all (\\<lambda>y. y \\<in> set xs) (z # zs)\" by simp\n  qed\nqed\n```", "fs_baseline_output": "```isabelle\nlemma list_all_mem_subset:\n  \"list_all (\\<lambda>y. y \\<in> set xs) ys = (set ys \\<subseteq> set xs)\"\n  by (induct ys arbitrary: xs) (auto simp: subset_insertI)\n```", "fs_cot_sketch": "- The lemma states that all elements of ys are in xs if and only if ys is a subset of xs.\n- Proof strategy: induction on ys.\n- Base case ys = []: both sides simplify to True.\n- Inductive case ys = y#ys': assume the lemma holds for ys', then show it holds for y#ys'.\n  - If y \\<in> set xs, then y#ys' is a subset of xs.\n  - If y \\<notin> set xs, then ys' is a subset of xs but y#ys' is not.\n- Tactics: (induct ys; simp; blast).", "fs_cot_output": "```isabelle\nlemma list_all_mem_subset:\n  \"list_all (\\<lambda>y. y \\<in> set xs) ys = (set ys \\<subseteq> set xs)\"\n  by (induct ys; simp; blast)\n```"}
{"input": "lemma F_all2_eq:\n  \"(\\<And>x xs'. x \\<in> set xs \\<Longrightarrow> set xs' \\<subseteq> set xs \\<Longrightarrow> F x x xs' xs') \\Longrightarrow> F_all2 F xs xs\"\n apply (simp add: F_all2_def)\n apply (rule_tac x=\"\\<lambda>x y. x \\<in> set xs \\<and> x = y\" in exI)\n apply (intro conjI impI allI)\n apply (drule list_all2_conjD)\n apply (simp add: list.rel_eq)\n apply (simp add: list_all2_to_list_all list_all_mem_subset)\n apply (rule list.rel_refl_strong;simp)\n done\n\nlemma F_all2_conjI:\n  \"F_all2 F xs ys \\<Longrightarrow> F_all2 F' xs ys \\<Longrightarrow>\n    F_all2 (\\<lambda>x y xs ys. F x y xs ys \\<and> F' x y xs ys) xs ys\"\n  apply (clarsimp simp: F_all2_def)\n  apply (rule_tac x=\"\\<lambda>x y. F'a x y \\<and> F'aa x y\" in exI)", "gt": "by (auto dest: list_all2_conjD intro: list_all2_conj)", "baseline_output": "```isabelle\nlemma F_all2_eq:\n  \"(\\<And>x xs'. x \\<in> set xs \\<Longrightarrow> set xs' \\<subseteq> set xs \\<Longrightarrow> F x x xs' xs') \\Longrightarrow> F_all2 F xs xs\"\n  apply (simp add: F_all2_def)\n  apply (rule_tac x=\"\\<lambda>x y. x \\<in> set xs \\<and> x = y\" in exI)\n  apply (intro conjI impI allI)\n  apply (drule list_all2_conjD)\n  apply (simp add: list.rel_eq)\n  apply (simp add: list_all2_to_list_all list_all_mem_subset)\n  apply (rule list.rel_refl_strong; simp)\n  done\n\nlemma F_all2_conjI:\n  \"F_all2 F xs ys \\<Longrightarrow> F_all2 F' xs ys \\<Longrightarrow>\n    F_all2 (\\<lambda>x y xs ys. F x y xs ys \\<and> F' x y xs ys) xs ys\"\n  apply (clarsimp simp: F_all2_def)\n  apply (rule_tac x=\"\\<lambda>x y. F'a x y \\<and> F'aa x y\" in exI)\n```", "cot_sketch": "- The lemmas relate properties of `F_all2` and its conjunction.\n- Proof strategy for `F_all2_eq`: use definition and existential introduction.\n- Key steps:\n  - Apply `simp` to unfold `F_all2_def`.\n  - Introduce an appropriate function using `exI`.\n  - Prove the conjunction using `conjI`, `impI`, and `allI`.\n  - Use `drule` to apply `list_all2_conjD`.\n  - Simplify using `list.rel_eq`, `list_all2_to_list_all`, and `list_all_mem_subset`.\n  - Finally, apply `list.rel_refl_strong` and `simp`.\n- Proof strategy for `F_all2_conjI`: use clarsimp and existential introduction.\n- Key steps:\n  - Apply `clarsimp` to simplify using `F_all2_def`.\n  - Introduce an appropriate function using `exI`.\n  - Prove the conjunction using `conjI`.", "cot_output": "```isabelle\nlemma F_all2_eq:\n  \"(\\<And>x xs'. x \\<in> set xs \\<Longrightarrow> set xs' \\<subseteq> set xs \\<Longrightarrow> F x x xs' xs') \\Longrightarrow> F_all2 F xs xs\"\napply (simp add: F_all2_def)\napply (rule_tac x=\"\\<lambda>x y. x \\<in> set xs \\<and> x = y\" in exI)\napply (intro conjI impI allI)\napply (drule list_all2_conjD)\napply (simp add: list.rel_eq)\napply (simp add: list_all2_to_list_all list_all_mem_subset)\napply (rule list.rel_refl_strong; simp)\ndone\n\nlemma F_all2_conjI:\n  \"F_all2 F xs ys \\<Longrightarrow> F_all2 F' xs ys \\<Longrightarrow>\n    F_all2 (\\<lambda>x y xs ys. F x y xs ys \\<and> F' x y xs ys) xs ys\"\napply (clarsimp simp: F_all2_def)\napply (rule_tac x=\"\\<lambda>x y. F'a x y \\<and> F'aa x y\" in exI)\napply (intro conjI)\ndone\n```", "fs_baseline_output": "```isabelle\nlemma F_all2_conjI:\n  \"F_all2 F xs ys \\<Longrightarrow> F_all2 F' xs ys \\<Longrightarrow>\n    F_all2 (\\<lambda>x y xs ys. F x y xs ys \\<and> F' x y xs ys) xs ys\"\n  apply (clarsimp simp: F_all2_def)\n  apply (rule_tac x=\"\\<lambda>x y. F'a x y \\<and> F'aa x y\" in exI)\n```", "fs_cot_sketch": "- The lemmas relate properties of `F_all2` and its conjunction with another property `F_all2`.\n- Proof strategy: clarsimp and rule_tac for introducing new variables and assumptions.\n- Base case: Use `clarsimp` to simplify the goal.\n- Inductive case: Introduce a new variable `x` and use `exI` to instantiate an existential quantifier.\n- Show that the conjunction holds by applying `list_all2_conjD`, `list.rel_eq`, and other simplification rules.\n- Apply `list.rel_refl_strong` to complete the proof.\n- Tactics: (clarsimp simp: F_all2_def; rule_tac x=\"\\<lambda>x y. x \\<in> set xs \\<and> x = y\" in exI; intro conjI impI allI; drule list_all2_conjD; simp add: list.rel_eq; simp add: list_all2_to_list_all list_all_mem_subset; rule list.rel_refl_strong; simp).", "fs_cot_output": "```isabelle\nlemma F_all2_eq:\n  \"(\\<And>x xs'. x \\<in> set xs \\<Longrightarrow> set xs' \\<subseteq> set xs \\<Longrightarrow> F x x xs' xs') \\Longrightarrow> F_all2 F xs xs\"\napply (simp add: F_all2_def)\napply (rule_tac x=\"\\<lambda>x y. x \\<in> set xs \\<and> x = y\" in exI)\napply (intro conjI impI allI)\napply (drule list_all2_conjD)\napply (simp add: list.rel_eq)\napply (simp add: list_all2_to_list_all list_all_mem_subset)\napply (rule list.rel_refl_strong; simp)\ndone\n\nlemma F_all2_conjI:\n  \"F_all2 F xs ys \\<Longrightarrow> F_all2 F' xs ys \\<Longrightarrow>\n    F_all2 (\\<lambda>x y xs ys. F x y xs ys \\<and> F' x y xs ys) xs ys\"\n  apply (clarsimp simp: F_all2_def)\n  apply (rule_tac x=\"\\<lambda>x y. F'a x y \\<and> F'aa x y\" in exI)\n```"}
{"input": "lemma corresK_mapM_list_all2:\n  assumes x: \"\\<And>x y xs ys. corres_underlyingK sr nf nf' (F x y xs ys) r' (I (x#xs)) (I' (y#ys)) (f x) (f' y)\"\n  assumes \"\\<And>x y xs. \\<lbrakk> S x y; suffix (x#xs) as \\rbrakk> \\Longrightarrow> \\<lbrace> I  (x#xs) \\<rbrace> f  x \\<lbrace> \\<lambda>rv. I  xs \\<rbrace>\"\n  assumes \"\\<And>x y ys. \\<lbrakk> S x y; suffix (y#ys) cs \\rbrakk> \\Longrightarrow> \\<lbrace> I' (y#ys) \\<rbrace> f' y \\<lbrace> \\<lambda>rv. I' ys \\<rbrace>\"\n  shows \"corres_underlyingK sr nf nf'\n          (r [] [] \\<and> (\\<forall> x y xs ys. r' x y \\longrightarrow> r xs ys \\longrightarrow> r (x # xs) (y # ys)) \\and>\n            list_all2 S as cs \\and> F_all2 F as cs)\n                            r (I as) (I' cs) (mapM f as) (mapM f' cs)\"\n  unfolding corres_underlyingK_def\n  apply (clarsimp simp: F_all2_def)\n  subgoal for F'\n  apply (rule corres_mapM_list_all2[of r r' \"\\<lambda>x y. S x y \\<and> F' x y\"]; (rule assms | assumption | clarsimp)?)\n  apply (rule x[THEN corresK_unlift])\n  apply (drule list_all2_conjD)\n  apply (clarsimp simp: assms | assumption)+\n  apply (rule list_all2_conj; simp)\n  done\n  done\n\nlemma corresK_discard_rv:\n  assumes A[corresK]: \"corres_underlyingK sr nf nf' F r' P P' a c\"\n  shows \"corres_underlyingK sr nf nf' F dc P P' (do x \\<leftarrow> a; return () od) (do x \\<leftarrow> c; return () od)\"", "gt": "by corresKsimp", "baseline_output": "```isabelle\nlemma corresK_discard_rv:\n  assumes A[corresK]: \"corres_underlyingK sr nf nf' F r' P P' a c\"\n  shows \"corres_underlyingK sr nf nf' F dc P P' (do x \\<leftarrow> a; return () od) (do x \\<leftarrow> c; return () od)\"\n  unfolding corres_underlyingK_def\n  apply (clarsimp simp: dc_def)\n  apply (rule corresK_bind)\n  apply (rule A)\n  apply (rule corresK_return)\n  apply (rule corresK_return)\n  done\n```", "cot_sketch": "- The lemma states that discarding the return value of two corresponding computations preserves their correspondence.\n- Proof strategy: use the definition of `corres_underlyingK` and properties of `return`.\n- Key steps:\n  - Unfold `corres_underlyingK` and `return`.\n  - Apply the given `A[corresK]` assumption.\n  - Simplify using properties of `return` and conjunction.\n- Tactics: (unfold corres_underlyingK_def return_def; simp add: A[corresK]).", "cot_output": "```isabelle\nlemma corresK_discard_rv:\n  assumes A[corresK]: \"corres_underlyingK sr nf nf' F r' P P' a c\"\n  shows \"corres_underlyingK sr nf nf' F dc P P' (do x \\<leftarrow> a; return () od) (do x \\<leftarrow> c; return () od)\"\n  unfolding corres_underlyingK_def return_def\n  apply (simp add: A[corresK])\n  done\n```", "fs_baseline_output": "```isabelle\nlemma corresK_discard_rv:\n  assumes A[corresK]: \"corres_underlyingK sr nf nf' F r' P P' a c\"\n  shows \"corres_underlyingK sr nf nf' F dc P P' (do x \\<leftarrow> a; return () od) (do x \\<leftarrow> c; return () od)\"\n  unfolding corres_underlyingK_def\n  apply (clarsimp simp: dc_def)\n  apply (rule_tac x=x in corresK)\n  apply (auto simp: A)\n  done\n```", "fs_cot_sketch": "- The lemmas relate correspondence properties under different conditions.\n- Proof strategy: use existing correspondences and assumptions.\n- Apply `corresK_unlift` to lift the correspondence from `a` to `c`.\n- Use `list_all2_conjD` to break down the conjunction in the premises.\n- Simplify using assumptions and existing correspondences.\n- Combine results using `list_all2_conj` and `corres_mapM_list_all2`.\n- Tactics: (clarsimp simp, rule corresK_unlift, drule list_all2_conjD, clarsimp, assumption).", "fs_cot_output": "```isabelle\nlemma corresK_discard_rv:\n  assumes A[corresK]: \"corres_underlyingK sr nf nf' F r' P P' a c\"\n  shows \"corres_underlyingK sr nf nf' F dc P P' (do x \\<leftarrow> a; return () od) (do x \\<leftarrow> c; return () od)\"\n  unfolding corres_underlyingK_def\n  apply (clarsimp simp: F_all2_def)\n  subgoal for F'\n  apply (rule corres_mapM_list_all2[of r r' \"\\<lambda>x y. S x y \\<and> F' x y\"]; (rule assms | assumption | clarsimp)?)\n  apply (rule x[THEN corresK_unlift])\n  apply (drule list_all2_conjD)\n  apply (clarsimp simp: assms | assumption)+\n  apply (rule list_all2_conj; simp)\n  done\n  done\n```"}
{"input": "lemma corresK_mapM_mapM_x:\n  assumes \"corres_underlyingK sr nf nf' F r' P P' (mapM f as) (mapM f' cs)\"\n  shows \"corres_underlyingK sr nf nf' F dc P P' (mapM_x f as) (mapM_x f' cs)\"", "gt": "by (rule corresK_discard_rv, rule assms)", "baseline_output": "```isabelle\nlemma corresK_mapM_mapM_x:\n  assumes \"corres_underlyingK sr nf nf' F r' P P' (mapM f as) (mapM f' cs)\"\n  shows \"corres_underlyingK sr nf nf' F dc P P' (mapM_x f as) (mapM_x f' cs)\"\n  using assms\n  unfolding mapM_x_def\n  by (wpsimp wp: corres_mapM)\n```", "cot_sketch": "- The lemma states that if two mapM operations are corresponding under certain conditions, then their corresponding counterparts (mapM_x) are also corresponding.\n- Proof strategy: induction on the length of the lists `as` and `cs`.\n- Base case: Both lists are empty (`[]`). Both sides of the equation simplify to `return ()`, which is trivially corresponding.\n- Inductive case: Assume `as = a#as'` and `cs = c#cs'`. Use the induction hypothesis (IH) to show that the recursive calls for `mapM` and `mapM_x` are corresponding.\n- Key tactics: (induct as cs arbitrary: a as' c cs'; simp add: corres_underlyingK_def).\n- Simplify using properties of `mapM` and `mapM_x`, and the given assumptions about `corres_underlyingK`.", "cot_output": "```isabelle\nlemma corresK_mapM_mapM_x:\n  assumes \"corres_underlyingK sr nf nf' F r' P P' (mapM f as) (mapM f' cs)\"\n  shows \"corres_underlyingK sr nf nf' F dc P P' (mapM_x f as) (mapM_x f' cs)\"\nproof -\n  have \"corres_underlyingK sr nf nf' F dc P P' (mapM_x f as) (mapM_x f' cs)\" if \"as = []\" \"cs = []\"\n    by simp\n  moreover\n  have \"corres_underlyingK sr nf nf' F dc P P' (mapM_x f as) (mapM_x f' cs)\" if \"as = a # as'\" \"cs = c # cs'\"\n  proof -\n    obtain d where \"dc = return (d :: unit)\" by simp\n    with that have \"corres_underlyingK sr nf nf' F dc P P' (mapM_x f as) (mapM_x f' cs)\"\n      unfolding corres_underlyingK_def\n      by (rule corres_return)\n    thus ?thesis\n      by simp\n  qed\n  ultimately show ?thesis\n    by blast\nqed\n```", "fs_baseline_output": "```isabelle\nlemma corresK_mapM_mapM_x:\n  assumes \"corres_underlyingK sr nf nf' F r' P P' (mapM f as) (mapM f' cs)\"\n  shows \"corres_underlyingK sr nf nf' F dc P P' (mapM_x f as) (mapM_x f' cs)\"\n  unfolding mapM_x_def\n  by (rule corres_mapM_x[OF assms])\n```", "fs_cot_sketch": "- The lemma states that if two mapM operations are corresponding under certain conditions, then their corresponding counterparts (mapM_x) are also corresponding.\n- Proof strategy: Use the definition of `corresponding_underlyingK` and properties of `mapM` and `mapM_x`.\n- Key steps:\n  - Expand the definition of `corresponding_underlyingK` for both `mapM` and `mapM_x`.\n  - Show that the conditions for `mapM_x` follow from those for `mapM` using the given assumptions.\n  - Simplify and use induction on the lists `as` and `cs` to handle the recursive nature of `mapM` and `mapM_x`.\n- Tactics: (unfold def, simp, induction, auto).", "fs_cot_output": "```isabelle\nlemma corresK_mapM_mapM_x:\n  assumes \"corres_underlyingK sr nf nf' F r' P P' (mapM f as) (mapM f' cs)\"\n  shows \"corres_underlyingK sr nf nf' F dc P P' (mapM_x f as) (mapM_x f' cs)\"\nproof -\n  have \"corres_underlyingK sr nf nf' F r' P P' (mapM f as) (mapM f' cs)\"\n    by fact\n  thus ?thesis\n    unfolding corresK_mapM_mapM_x_def\n    by (auto simp: corres_underlyingK_def corres_mapM_def corres_mapM_x_def)\nqed\n```"}
{"input": "lemma corresK_subst_both: \"g' = f' \\<Longrightarrow> g = f \\<Longrightarrow>\n  corres_underlyingK sr nf nf' F r P P' f f' \\<Longrightarrow>", "gt": "by simp", "baseline_output": "```isabelle\nlemma corresK_subst_both: \"g' = f' \\<Longrightarrow> g = f \\<Longrightarrow>\n  corres_underlyingK sr nf nf' F r P P' f f' \\<Longrightarrow>\n  corres_underlyingK sr nf nf' F r P P' g g'\"\n  by simp\n```", "cot_sketch": "- The lemma involves substituting equivalent functions into a correspondence relation.\n- Strategy: Use substitution properties and congruence rules for `corres_underlyingK`.\n- Key steps:\n  - Substitute `f'` with `g'` in the premise `g' = f'`.\n  - Substitute `f` with `g` in the premise `g = f`.\n  - Apply the congruence rule for `corres_underlyingK` to handle the substituted premises.\n- Tactics: (substitute, congruence).", "cot_output": "```isabelle\nlemma corresK_subst_both: \"g' = f' \\<Longrightarrow> g = f \\<Longrightarrow>\n  corres_underlyingK sr nf nf' F r P P' f f' \\<Longrightarrow>\n  corres_underlyingK sr nf nf' F r P P' g' g\"\nproof -\n  assume \"g' = f'\" and \"g = f\" and \"corres_underlyingK sr nf nf' F r P P' f f'\"\n  have \"corres_underlyingK sr nf nf' F r P P' g' g\"\n    unfolding corres_underlyingK_def\n    using `g' = f'` `g = f` `corres_underlyingK sr nf nf' F r P P' f f'`\n    by (rule corres_congruent2)\n  thus ?thesis .\nqed\n```", "fs_baseline_output": "```isabelle\nlemma corresK_subst_both: \"g' = f' \\<Longrightarrow> g = f \\<Longrightarrow>\n  corres_underlyingK sr nf nf' F r P P' f f' \\<Longrightarrow>\n  corres_underlyingK sr nf nf' F r P P' g h\"\n  by simp\n```", "fs_cot_sketch": "- The lemma involves substituting equal functions into a correspondence relation.\n- Strategy: Use substitution properties of equality.\n- Key observation: If `g' = f'` and `g = f`, then any expression involving `f` can be replaced with `g` and vice versa without changing the truth value.\n- Apply substitution to the premise `corres_underlyingK sr nf nf' F r P P' f f'`.\n- Simplify using the given equalities `g' = f'` and `g = f`.\n- Conclusion follows directly from the simplified premise.\n- Tactics: (subgoal_tac, simp).", "fs_cot_output": "```isabelle\nlemma corresK_subst_both: \"g' = f' \\<Longrightarrow> g = f \\<Longrightarrow>\n  corres_underlyingK sr nf nf' F r P P' f f' \\<Longrightarrow>\n  corres_underlyingK sr nf nf' F r P P' g g'\"\n  by (subgoal_tac \"f' = g' \\<and> f = g\" | simp)\n```"}
